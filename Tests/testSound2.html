<!DOCTYPE html>
<html>
<head>
    <title>Pitch detection test</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- from article at https://alexanderell.is/posts/tuner/ -->
    <style>
        body {
            margin: 5px;
            font-size: large;
        }

        input {
            font-size: initial;
        }
        .visualizer {
            width : 99%;
            margin-left: 0.5%;
            height: 512px;
        }

        #warning {
            display: none;
            color: red;
            font-weight: bolder;
        }

        .E3D_fullscreenContainer {
            position:fixed;
            top:0px;
            bottom:0px;
            right:0px;
            left:0px;
        }

        .E3D_flexVertical {
            display: flex;
            flex-direction: column;
        }
        .E3D_flexHorizontal {
            display: flex;
            flex-direction: row;
        }
        .E3D_flexContent {
            overflow: hidden;
            flex: 1 1 auto;
        }
        .E3D_flexVerticalContentFixed {
            width: 100%;
            height: fit-content;
        }
        .E3D_flexHorizontalContentFixed {
            width: fit-content;
            height: 100%;
        }

        .E3D_fakeButton {
            cursor: pointer;
            background-color: #d0d0d0;
            padding-right: 0.2em;
            padding-left: 0.2em;
            user-select: none;
            box-shadow: 0.1em 0.1em black;
            border-radius: 0.2em;
            margin: 0.1em 0.2em 0.2em 0.2em;
            display: inline-block;
        }
        .E3D_fakeButton:hover {
            background-color: #a0a0a0;
        }

        #footer {
            position: fixed;
            bottom:0px;
            right:0px;
        }
        /* Table Styles */
        table {
            border-collapse: separate;
            border: 0px solid #808080;/*grayBackground*/
            border-spacing: 0px 5px;
            margin: 0px 15px 15px 15px;
        }

        tr:nth-child(even) {
            background-color: #E2E2ED;/**/
        }
        tr:nth-child(odd) {
            background-color:#F2F2FD;/*lightBackground*/
        }
        th {
            color:#F2F2FD;/*lightBackground*/
            background-color:#505050;
            border-radius: 5px;
            box-shadow: 0px 3px 3px 0px #303030;
            padding: 2px 10px 0px 10px;
        }
        td {
            padding: 2px 10px 0px 10px;
            width:10em;
        }
        td:nth-child(odd) {
            text-align: right;
            width:6em;
        }


    </style>
    <script type="text/javascript">
document.addEventListener("DOMContentLoaded", function() {

function getElem(id) {
    var elem = document.getElementById(id);
    if (elem) return elem;
    return false;
}

function onClick(elemOrID, callback) {
    if (typeof(elemOrID) == "string") elemOrID = getElem(elemOrID);
    if (elemOrID) elemOrID.addEventListener("click", callback);
}

function onEvent(elemOrID, event, callback) {
    if (typeof(elemOrID) == "string") elemOrID = getElem(elemOrID);
    if (elemOrID) elemOrID.addEventListener(event, callback);
}

function smooth(val, target, factor) {
    if (factor > 1.0) return target;
    return val + ((target - val) * factor);
}
function warn(text) {
    var warning = getElem("warning");
    warning.style.display = "block";
    warning.innerText = text;
}
function pararbInterpolate(index, prevValue, value, nextValue) {
    var newIndex = index;
    var a = (prevValue + nextValue - (2.0 * value)) / 2.0;
    var b = (nextValue - prevValue) / 2.0;
    if (a) {
        newIndex = index - b / (2.0 * a);
    }
    if (isNaN(newIndex)) return index;
    if (newIndex == Infinity) return index;
    if (newIndex == -Infinity) return index;
    return newIndex;
}

// data output elements
var FFT_lin_peak = getElem("FFT_lin_peak");
var FFT_lin_peakValue = 0.0;
var FFT_lin_freq = getElem("FFT_lin_freq");
var FFT_lin_freqValue = 0.0;
var FFT_lin_note = getElem("FFT_lin_note");
var FFT_lin_chevron = 0;
var FFT_lin_mark = 440;
var FFT_lin_text = getElem("FFT_lin_text");
var FFT_lin_smoothValue = 0.5;
onEvent("FFT_lin_smooth", "input", (event) => {
    FFT_lin_smoothValue = (Number(event.target.value) / 100.0);
    FFT_lin_text.innerText ="Sm:" + FFT_lin_smoothValue.toFixed(3) + " Sq:" + FFT_lin_squelchValue;
} );
var FFT_lin_squelchValue = 64;
onEvent("FFT_lin_squelch", "input", (event) => {
    FFT_lin_squelchValue = Number(event.target.value);
    FFT_lin_text.innerText ="Sm:" + FFT_lin_smoothValue.toFixed(3) + " Sq:" + FFT_lin_squelchValue;
} );
var FFT_lin_bassValue = 8;
onEvent("FFT_lin_bass", "input", (event) => {
    FFT_lin_bassValue = Number(event.target.value);
    FFT_lin_text.innerText ="Sm:" + FFT_lin_smoothValue.toFixed(3) + " Sq:" + FFT_lin_squelchValue;
} );
var AC_lin_freq1 = getElem("AC_lin_freq1");
var AC_lin_freq1Value = 0.0;
var AC_lin_note1 = getElem("AC_lin_note1");
var AC_lin_chevron1 = 0;
var AC_lin_mark1 = 440;

var AC_lin_freq2 = getElem("AC_lin_freq2");
var AC_lin_freq2Value = 0.0;
var AC_lin_note2 = getElem("AC_lin_note2");
var AC_lin_chevron2 = 0;
var AC_lin_mark2 = 440;

var AC_lin_text = getElem("AC_lin_text");
var AC_lin_smoothValue = 0.9;
onEvent("AC_lin_smooth", "input", (event) => {
    AC_lin_smoothValue = Number(event.target.value) / 100.0;
    AC_lin_text.innerText = "Sm:" + AC_lin_smoothValue.toFixed(3) + " Sq:" + AC_lin_squelchValue.toFixed(3);
} );
var AC_lin_squelchValue = 0.002;
onEvent("AC_lin_squelch", "input", (event) => {
    AC_lin_squelchValue = Number(event.target.value) / 10000.0;
    AC_lin_text.innerText = "Sm:" + AC_lin_smoothValue.toFixed(3) + " Sq:" + AC_lin_squelchValue.toFixed(4);
} );

// events
onClick("startButton", init);
onClick("toggleButton", (event) => {
    if (!audioContext) return;
    if (audioContext.state == "running") {
        audioContext.suspend();
        event.target.innerText = "Resume";
    } else {
        audioContext.resume();
        event.target.innerText = "Pause";
    }
});
onEvent("toneEnable", "change", setToneVol);
onEvent("toneVol", "input", setToneVol);
onEvent("toneFreq", "input", (event) => {
    if (oscillatorTone) oscillatorTone.frequency.value = Number(getElem("toneFreq").value);
} );
function setToneVol() {
    if (!gainNodeTone) return;
    gainNodeTone.gain.value = (getElem("toneEnable").checked) ? Number(getElem("toneVol").value) : 0.0;
    oscillatorTone.frequency.value = Number(getElem("toneFreq").value);
}
onEvent("baseFreq", "change", (event) => baseFreq = Number(event.target.value));




// global
var source;
var audioContext;
var analyser;
var sampleRate;
var analyserSize;

var gainNodeMet, gainNodeTone;
var oscillatorTone;
var baseFreq = 440.0;

// Visualizing, copied from voice change o matic
var canvas = document.querySelector('.visualizer');
canvas.width = canvas.offsetWidth;
var canvasContext = canvas.getContext("2d");
var WIDTH;
var HEIGHT;

function init() {
    if (audioContext) return;
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        sampleRate = audioContext.sampleRate;
        getElem("rate").innerText = sampleRate;
        analyser = audioContext.createAnalyser();
        analyser.minDecibels = -100;
        analyser.maxDecibels = -10;
        analyser.smoothingTimeConstant = 0.1;
        analyser.fftSize = 4096;
        analyserSize = analyser.fftSize;
        getElem("size").innerText = analyserSize;
    } catch (err) {
        warn(err);
        return;
    }

    if (!navigator?.mediaDevices?.getUserMedia) {
        // No audio allowed
        warn('Sorry, getUserMedia is required for the app.')
        return;
    } else {
        navigator.mediaDevices.getUserMedia({audio: true}).then(
            function(stream) {
                // Initialize the SourceNode
                source = audioContext.createMediaStreamSource(stream);
                // Connect the source node to the analyzer
                source.connect(analyser);

                gainNodeTone = audioContext.createGain();
                gainNodeTone.connect(audioContext.destination);
                gainNodeTone.gain.value = 0;

                oscillatorTone = audioContext.createOscillator();
                oscillatorTone.connect(gainNodeTone);
                oscillatorTone.start();

                init_visualize();
            }
        ).catch(function(err) {
            warn(err);
        }
    );}
}// init

function init_visualize() {
    WIDTH = canvas.width;
    HEIGHT = canvas.height;

    var bufferLengthAlt = analyser.frequencyBinCount;
    var dataArrayAlt = new Uint8Array(bufferLengthAlt);
    canvasContext.clearRect(0, 0, WIDTH, HEIGHT);

    var drawGraph = function() {
        requestAnimationFrame(drawGraph);

        analyser.getByteFrequencyData(dataArrayAlt);

        canvasContext.fillStyle = 'rgb(0, 0, 0)';
        canvasContext.fillRect(0, 0, WIDTH, HEIGHT);

        canvasContext.fillStyle = "white";
        canvasContext.strokeStyle = "white";

        var graphNoteMin = -9; // C0 - 1
        //var graphNoteMin = -8; // C0 16.35160
        // note  1 A0 is 27.50000
        // note 88 C8 is 4196.009
        // fft of 4096
        // samples of 48000
        // fft 4095 is 24000
        // fft 0 is 0
        // fft 1 is 5.859
        // C0 is at fft 2.79
        //var graphNoteMax = 99; // B8 7902.133
        var graphNoteMax = 100; // B8 7902.133
        // 99 + 0 -1 -2 -3 -4 -5 -6 -7 -8
        // 108 notes

        // 110 notes
        // split in 100 log cent
        // 11000 slices
        // -900 to 10000
        var graphFreqhMin = getLogFreq(graphNoteMin); // 16.351
        var graphFreqhMax = getLogFreq(graphNoteMax); // 7902.133
        canvasContext.textAlign = 'center';
        //canvasContext.textBaseline = "bottom";

        // draw scale
        for (var i = graphNoteMin; i <= graphNoteMax; ++i) {
            var x = (i - graphNoteMin) / (graphNoteMax - graphNoteMin);
            x = x * WIDTH;
            if ((i % 12) == 1) { // Ai
                canvasContext.beginPath();
                canvasContext.moveTo(x, 0);
                canvasContext.lineTo(x, 512);
                canvasContext.stroke();
                canvasContext.font = "bold 12px Arial";
                canvasContext.fillText("A" + Math.floor(i / 12), x, 256+16);
                canvasContext.fillText(getLogFreq(i).toFixed(1), x, 256-20);
            } else {
                canvasContext.beginPath();
                canvasContext.moveTo(x, 256-16);
                canvasContext.lineTo(x, 256+16);
                canvasContext.stroke();
                canvasContext.font = "10px Arial";
                var str = noteStringFromIndex(i+20);
                canvasContext.fillText(str, x, 260 + ((str.length > 2) ? -4 : 4) );
            }
        }

        canvasContext.textAlign = 'left';

        var numCent = ((graphNoteMax - graphNoteMin + 1 ) * 100);
        var barWidth = WIDTH / numCent;
        var barHeight;
        var x = 0;
        var localPeakValue = 0;
        var localPeakFreq = 0;
        var fPerSample = (sampleRate / 2.0) / bufferLengthAlt;

        /*var prevCentFreq=getCentFreq2(graphNoteMin * 100);
        var currentCentFreq=getCentFreq2(graphNoteMin * 100 + 1);
        var nextCentFreq=0;*/

        var bassBoostM = -FFT_lin_bassValue / (numCent / 1.5); // cutoff at 2/3 scale
        var bassBoostB = FFT_lin_bassValue - (bassBoostM * graphNoteMin * 100 * 1.5);

        // draw FFT_lin
        for (var cent = graphNoteMin * 100 + 1; cent <= graphNoteMax * 100 - 1; ++cent) {

            var freq = getCentFreq2(cent);
            var sample = freq / fPerSample;

            var baseIndex = Math.floor(sample);
            var ratio = sample - baseIndex;
            barHeight = ((1.0-ratio) * dataArrayAlt[baseIndex]) + (ratio*dataArrayAlt[baseIndex + 1]);

            barHeight = barHeight + (bassBoostM * cent) + bassBoostB;

            canvasContext.fillStyle = 'rgb(' + (64 + (3*barHeight/4)) + ',50,50)';
            var x = (cent - (graphNoteMin * 100)) / ((graphNoteMax - graphNoteMin) * 100);
            x = x * WIDTH;
            canvasContext.fillRect(x, HEIGHT - barHeight, barWidth, barHeight);

            if ((barHeight > localPeakValue) && (baseIndex > 0) && (baseIndex < dataArrayAlt.length - 2)) {
                let prev = dataArrayAlt[baseIndex - 1];
                let curr = dataArrayAlt[baseIndex];
                let next = dataArrayAlt[baseIndex + 1];
                var newIndex = pararbInterpolate(baseIndex, prev, curr, next);
                if (newIndex < 0) newIndex = 0;
                localPeakValue = barHeight;
                localPeakFreq = newIndex * fPerSample;
            }


            canvasContext.globalCompositeOperation = "lighter";
            if (FFT_lin_chevron == cent) {
                canvasContext.fillStyle = "red";
                canvasContext.beginPath();
                canvasContext.moveTo(x, 256+16);
                canvasContext.lineTo(x-7, 256+16+10);
                canvasContext.lineTo(x+7, 256+16+10);
                canvasContext.fill();
            }
            if (FFT_lin_mark == cent) {
                canvasContext.strokeStyle = "red";
                canvasContext.beginPath();
                canvasContext.moveTo(x, 256+16);
                canvasContext.lineTo(x-7, 256+16+10);
                canvasContext.lineTo(x+7, 256+16+10);
                canvasContext.lineTo(x, 256+16);
                canvasContext.stroke();
            }

            if (AC_lin_chevron1 == cent) {
                canvasContext.fillStyle = "blue";
                canvasContext.beginPath();
                canvasContext.moveTo(x, 256-16);
                canvasContext.lineTo(x-7, 256-16-10);
                canvasContext.lineTo(x+7, 256-16-10);
                canvasContext.fill();
            }
            if (AC_lin_mark1 == cent) {
                canvasContext.strokeStyle = "blue";
                canvasContext.beginPath();
                canvasContext.moveTo(x, 256-16);
                canvasContext.lineTo(x-7, 256-16-10);
                canvasContext.lineTo(x+7, 256-16-10);
                canvasContext.lineTo(x, 256-16);
                canvasContext.stroke();
            }
            if (AC_lin_chevron2 == cent) {
                canvasContext.fillStyle = "white";
                canvasContext.beginPath();
                canvasContext.moveTo(x, 256-16);
                canvasContext.lineTo(x-7, 256-16-10);
                canvasContext.lineTo(x+7, 256-16-10);
                canvasContext.fill();
            }
            if (AC_lin_mark2 == cent) {
                canvasContext.strokeStyle = "white";
                canvasContext.beginPath();
                canvasContext.moveTo(x, 256-16);
                canvasContext.lineTo(x-7, 256-16-10);
                canvasContext.lineTo(x+7, 256-16-10);
                canvasContext.lineTo(x, 256-16);
                canvasContext.stroke();
            }
            canvasContext.globalCompositeOperation = "source-over";
        }

        // calculate frequency from FFT_lin
        FFT_lin_peakValue = smooth(FFT_lin_peakValue, localPeakValue, FFT_lin_smoothValue);
        FFT_lin_peak.innerText =  Math.round(FFT_lin_peakValue);

        if ( !isNaN(localPeakFreq) && (FFT_lin_peakValue > FFT_lin_squelchValue) ) {
            FFT_lin_freqValue = smooth(FFT_lin_freqValue, localPeakFreq, FFT_lin_smoothValue);
            FFT_lin_freq.innerText = FFT_lin_freqValue.toFixed(1);


            FFT_lin_mark = Math.round(getCent(localPeakFreq));
            let fcent = Math.round(getCent(FFT_lin_freqValue));
            FFT_lin_chevron = fcent;
            let error = Math.round(100*((fcent/100) - Math.round(fcent/100)));
            error = (error > 0) ? "+" + error : "" + error;
            FFT_lin_note.innerText = noteStringFromPitch(FFT_lin_freqValue) + " (" + error + " cents)";
        }

        // draw AC_lin
        let maxOffsetSize = sampleRate / graphFreqhMin;
        let sums = get_AC_lin(maxOffsetSize);
        if (sums != false) {

            barWidth = WIDTH / sums.length;
            var crossings = [];
            var peaks = [];
            var wasDown = false;
            canvasContext.fillStyle = "cyan";
            for (var x = 0; x < sums.length-1; ++x) {
                barHeight = sums[x] * 100.0;
                canvasContext.fillRect(WIDTH * x / sums.length, HEIGHT - barHeight - 256.0 - 128.0, barWidth, barHeight);
                if ( ((sums[x] < 0.0) && (sums[x+1] > 0.0)) || ((sums[x] > 0.0) && (sums[x+1] < 0.0))) {
                    // zero crossing
                    canvasContext.strokeStyle = "yellow";
                    canvasContext.beginPath();
                    canvasContext.moveTo(WIDTH * x / sums.length, 128.0-8.0);
                    canvasContext.lineTo(WIDTH * x / sums.length, 128.0+8.0);
                    canvasContext.stroke();
                    crossings.push(x);
                }
                // trough
                if ((x > 0) && (x < sums.length - 2) && (sums[x] < 0.0) && (sums[x-1] > sums[x]) && (sums[x] < sums[x+1])) {
                    wasDown = true;
                }
                if ((x > 0) && (x < sums.length - 2) && (sums[x] > 0.0) && (sums[x-1] < sums[x]) && (sums[x] > sums[x+1])) {
                    if (wasDown) { // new peak
                        peaks.push([x,  sums[x-1], sums[x], sums[x-1]]); // add to list
                        wasDown = false;
                    } else if ( (peaks.length > 0) && (peaks[peaks.length-1][2] < sums[x]) ) {
                        peaks[peaks.length-1] = [x,  sums[x-1], sums[x], sums[x-1]];// override if higher
                    }
                    // peaks
                    canvasContext.strokeStyle = "yellow";
                    canvasContext.beginPath();
                    canvasContext.moveTo(WIDTH * x / sums.length, HEIGHT - barHeight - 256.0 - 128.0);
                    canvasContext.lineTo(WIDTH * x / sums.length, HEIGHT - barHeight - 256.0 - 132.0);
                    canvasContext.stroke();
                }
            }

            // calculate freq from AC_lin
            if (crossings.length >= 5) {
                var dc12 = crossings[1]-crossings[0];
                var dc23 = crossings[2]-crossings[1];
                var dc34 = crossings[3]-crossings[2];
                var dc45 = crossings[4]-crossings[3];
                if ( (Math.abs(dc45 - dc34) / dc45) < 0.25) {
                    var stack = 0;
                    var numSpans = 0;
                    for (var i = 1; i < crossings.length/2; ++i) {stack += (crossings[i+1] - crossings[i]); numSpans++; }
                    var localFreq1 = sampleRate / (stack*2.0/numSpans);

                    AC_lin_freq1Value = smooth(AC_lin_freq1Value, localFreq1, AC_lin_smoothValue);
                    AC_lin_freq1.innerText = AC_lin_freq1Value.toFixed(1);

                    AC_lin_mark1 = Math.round(getCent(localFreq1));
                    let fcent = Math.round(getCent(AC_lin_freq1Value));
                    AC_lin_chevron1 = fcent;
                    let error = Math.round(100*((fcent/100) - Math.round(fcent/100)));
                    error = (error > 0) ? "+" + error : "" + error;
                    AC_lin_note1.innerText = noteStringFromPitch(AC_lin_freq1Value) + " (" + error + " cents)";
                }  // crossings
                if (peaks.length > 10) {
                    // clean sub peaks
                    let hadSub = true;
                    while (hadSub) {
                        hadSub = false;
                        for (var i = peaks.length-1; i >=1; --i) {
                            if (peaks[i-1][2] < peaks[i][2]) {
                                peaks.splice(i-1, 1);
                                hadSub = true;
                            }
                        }
                    }
                    // get intervals
                    if (peaks.length > 5) {
                        for (var i = 0; i < 6; ++i) peaks[i][0] = pararbInterpolate(peaks[i][0], peaks[i][1], peaks[i][2], peaks[i][3]);

                        var localFreq2 = sampleRate / (peaks[2][0] - peaks[1][0]);
                        AC_lin_freq2Value = smooth(AC_lin_freq2Value, localFreq2, AC_lin_smoothValue);
                        AC_lin_freq2.innerText = AC_lin_freq2Value.toFixed(1);

                        AC_lin_mark2 = Math.round(getCent(localFreq2));
                        let fcent = Math.round(getCent(AC_lin_freq2Value));
                        AC_lin_chevron2 = fcent;
                        let error = Math.round(100*((fcent/100) - Math.round(fcent/100)));
                        error = (error > 0) ? "+" + error : "" + error;
                        AC_lin_note2.innerText = noteStringFromPitch(AC_lin_freq2Value) + " (" + error + " cents)";
                    }
                } // peaks


            } // 5 crossings
        } // sums over squelch


        // draw graph labels
        canvasContext.font = "bold 16px Arial";
        canvasContext.fillStyle = "white";
        canvasContext.fillText("FFT:", 4, 256+32);
        canvasContext.fillText("Autocorrelation:", 4, 16);
      };

    drawGraph();
}



const log_baseFactor = Math.pow(2.0, 1.0/12.0);
const log_unison = 49;
// note 1 is A0 at 27.5Hz
// note 49 is A4 at 440.0Hz
// note 88 is C8 at 4186.0hz
function getLogFreq(offset) {
    return baseFreq * Math.pow(log_baseFactor, (offset - log_unison));
}
function getLogFreq2(offset) {
    return 440.0 * Math.pow(Math.pow(2.0, 1.0/12.0), (offset - 49));
}
const cent_baseFactor = Math.pow(2.0, 1.0/1200.0);
const cent_unison = 4900;
function getCentFreq(offset) {
    return baseFreq * Math.pow(cent_baseFactor, (offset - cent_unison));
}
function getCentFreq2(offset) {
    return 440.0 * Math.pow(Math.pow(2.0, 1.0/1200.0), (offset - 4900));
}
function getCent(frequency) {
    var noteNum = 1200.0 * (Math.log( frequency / baseFreq ) / Math.log(2.0) );
    return noteNum + 4900.0;
}
// Thanks to PitchDetect: https://github.com/cwilso/PitchDetect/blob/master/js/pitchdetect.js
var noteStrings = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
function noteStringFromPitch(frequency) {
    var index = noteIndexFromPitch(frequency);
    var octave = Math.floor(index / 12)-1;
    var str = noteStrings[index % noteStrings.length];
    return (str.length == 1) ? (str + octave) : (str[0] + octave + str[1]);
}
function noteStringFromIndex(index) {
    var octave = Math.floor(index / 12)-1;
    var str = noteStrings[index % noteStrings.length];
    return (str.length == 1) ? (str + octave) : (str[0] + octave + str[1]);
}
function noteIndexFromPitch(frequency) {
    var noteNum = 12 * (Math.log( frequency / baseFreq )/Math.log(2) );
    if (noteNum < 69) noteNum = 69;
    return (Math.round( noteNum ) + 69);
}

function get_AC_lin(offsetSize)  {
    // Start with a bufferLength of the analyser's FFT size
    var bufferLength = analyser.fftSize;
    // Actually create the buffer
    var buffer = new Float32Array(bufferLength);
    // Populate the buffer with the time domain data
    analyser.getFloatTimeDomainData(buffer);

    // Create a new array of the sums of offsets to do the autocorrelation
    var offsetSums = new Array(bufferLength).fill(0.0);
    // For each potential offset, calculate the sum of each buffer value times its offset value
    for (let offset = 0; offset < bufferLength; offset++) {
        for (let j = 0; j < offsetSize - offset; j++) {
            offsetSums[offset] += buffer[j] * buffer[j+offset]
        }
    }

    // Calculate the offset with the highest value
    var maxValue = -1.0;
    var bestOffset = -1.0;
    for (var i = 0; i < offsetSums.length; i++) {
        if (offsetSums[i] > maxValue) {
            maxValue = offsetSums[i];
            bestOffset = i;
        }
    }

    if (maxValue < AC_lin_squelchValue) return false;
    // normalize
    for (let offset = 0; offset < bufferLength; offset++) offsetSums[offset] /= maxValue;

    return offsetSums;
}



        } );
    </script>
</head>

<body>
    <div id="warning"></div>
<div id="startButton" class="E3D_fakeButton">Enable</div><div id="toggleButton" class="E3D_fakeButton">Pause</div><br />

<input id="toneVol" type="range" min="0.0" max="0.5" value="0.25" step="0.05" />Tone Volume<br />
<input id="toneFreq" type="number" min="20" max="24000" value="440" />Hz <input type="checkbox" id="toneEnable" /> Play Tone <br />
<!--input id="metVol" type="range" min="0.0" max="0.5" value="0.25" step="0.05" />Metronome Volume<br />
BPM
4/4<br /-->
<hr />
Base A: <input type="number" min="0" max="24000" value="440" id="baseFreq" /><br />
Sample Rate: <span id="rate">0</span>, FFT Size: <span id="size">0</span><br />
<hr />
<canvas class="visualizer" width="1024" height="512"></canvas><br />
<table>
    <tr>
        <th colspan="4">Autocorrellation (Linear, first interval)</th>
        <th colspan="4">FFT (Linear, parabolic interpolation, highest peak)</th>
    </tr>
    <tr>
        <td>Smoothing:</td><td><input type="range" id="AC_lin_smooth" min="1" max="100" value="90" /></td>
        <td>Freq(ZC):</td><td><span id="AC_lin_freq1">0</span>Hz</td>
        <td>Smoothing:</td><td><input type="range" id="FFT_lin_smooth" min="1" max="100" value="20" /></td>
        <td>Freq:</td><td><span id="FFT_lin_freq">0</span>Hz</td>
    </tr>
    <tr>
        <td>Squelch:</td><td><input type="range" id="AC_lin_squelch" min="0" max="100" value="50" /></td>
        <td>Freq(P2P):</td><td><span id="AC_lin_freq2">0</span>Hz</td>
        <td>Squelch:</td><td><input type="range" id="FFT_lin_squelch" min="0" max="256" value="64" /></td>
        <td>Peak:</td><td><span id="FFT_lin_peak">0</span></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td>&nbsp;</td>
        <td>Note(ZC):</td><td><span id="AC_lin_note1">A</span></td>
        <td>Bass Amp:</td><td><input type="range" id="FFT_lin_bass" min="0" max="128" value="8" /></td>
        <td>Note:</td><td><span id="FFT_lin_note">A</span></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><span id="AC_lin_text"></span></td>
        <td>Note(P2P):</td><td><span id="AC_lin_note2">A</span></td>
        <td>&nbsp;</td><td><span id="FFT_lin_text"></span></td>
        <td>&nbsp;</td><td>&nbsp;</td>
    </tr>
</table>
<hr />
Standard frequencies<br />
Piano:<br />
note 1 is A0 at 27.5Hz<br />
note 41 is C4 at 261.6256Hz (Middle C)<br />
note 49 is A4 at 440.0Hz<br />
note 88 is C8 at 4186.009Hz<br />
Guitar:<br />
E2 82.40689Hz<br />
A2 110.0000Hz<br />
D3 146.8324Hz<br />
G3 195.9977Hz<br />
B3 246.9417Hz<br />
E4 329.6276Hz<br />
Violin:<br />
G3 195.9977Hz<br />
D4 293.6648Hz<br />
A4 440.0000Hz<br />
E5 659.2551Hz<br />
Phone dial tone:<br />
350Hz + 440Hz<br />
<div id="footer">Emmanuel Charette Nov-2022, based on article at <a href="https://alexanderell.is/posts/tuner/">https://alexanderell.is/posts/tuner/"</a></div>
</body>

</html>
