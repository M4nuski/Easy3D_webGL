<!DOCTYPE html>
<html>
<head>
    <title>Memory Game 2.4</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="media/memory.ico">
    <style>
        /* global */
        body {
            margin: 0px;
            font-size: 18px;
            font-family: Arial, Helvetica, sans-serif;
        }        
        canvas {
            width: 100%;
            height: 100%;
            z-index: 0;
            position: relative;
        }

        /* classes */
        .hoverSize {
            max-width: 50px;
            max-height: 50px;
            background-color: rgba(255, 255, 255, 0.25);

            transition: all 0.1s linear;
        }      
        .hoverSize:hover{
            max-width: 500px;
            max-height: 500px; /* should be equal to max-width to avoid transition overshoot */
            background-color: rgba(255, 255, 255, 0.95);
        }

        /* standard E3D classes */
        .E3D_fullscreenContainer {
            position:fixed;
            top:0px;
            bottom:0px;
            right:0px;
            left:0px;
        }
        .E3D_margin {
            margin: 0.25em;
        }
        .E3D_fakeButton {
            cursor: pointer;
            background-color: #d0d0d0;   
            padding-right: 0.2em;
            padding-left: 0.2em;   
            user-select: none;   
            box-shadow: 0.1em 0.1em black;      
            border-radius: 0.2em; 
            margin: 0.1em 0.2em 0.2em 0.2em;
        }
        .E3D_fakeButton:hover {
            background-color: #a0a0a0;
        }
        .E3D_flexContent {
            overflow: hidden;
            flex: 1 1 auto;
        }
        .E3D_flexVertical {
            display: flex;
            flex-direction: column;
        }
        .E3D_flexVerticalContentFit {
            width: 100%;
            height: fit-content;
        }
        .E3D_monospaceText {
            white-space: pre-wrap;
            font-family: 'Courier New', Courier, monospace;
            line-height: 18px;
        }

        /* score tabs */
        .E3D_tabButton {
            cursor: pointer;
            border: solid 1px black;
            background-color: #d0d0d0;   
            padding: 0.3em 0.2em 0.2em 0.2em;
            user-select: none;   
            box-shadow: 0.1em 0.1em black;      
            border-radius: 0.5em 0.5em 0em 0em;
            margin: 0.1em 0.0em 0.2em 0.1em;
        }
        .E3D_tabButton:hover {
            background-color: #a0a0a0;
        }
        .E3D_tabButtonActive {
            background-color: white;
        }
        .E3D_tabContent {
            display: none;
            margin-top: 4px;
            border-top: 2px solid black;
        }

        /* per element */
        #hiddenMedia {
            display: none;
        }

        #statusDiv {
            z-index: 10;
            border-bottom: 2px solid black;
            padding-left: 14px;
            font-weight: bold;
        }
        #helpDiv {
            z-index: 10;
            position: absolute;
            bottom: 0px;
            left: 0px;
            padding: 5px;
            border-radius: 5px;
            border: 2px solid black;
            margin: 2px;
            overflow: hidden;
            background-color: white;
            font-size: 16px;
        }
        #volDiv {
            z-index: 10;
            position: absolute;
            display: inline-block;
            left: 0px;
            text-align: center;
            border-radius: 5px;
            border: 2px solid black;
            margin: 2px;
            background-color: white;
        }
        #volSpan {
            display: block;
        }

        #scoreButtonDiv {
            z-index: 10;
            position: absolute;
            display: inline-block;
            right: 0px;
            border-radius: 5px;
            border: 2px solid black;
            margin: 2px;
            background-color: white;
        }
        #scoreButtonDiv:hover {
            background-color: #a0a0a0;
        }
        #scoreCloseButton {
            margin: 5px;
            right: 0.8em;
            position: absolute;
            background-color: salmon;
        }
        #scoreCloseButton:hover {
            background-color:#f83620;
        }
        
        #scoreDiv {
            /* Score Div is a "modal" panel hiding the game and inhibiting the game loop */ 
            position: fixed;
            visibility: hidden;
            z-index: 50;
            top: 0px;
            left:0px;
            bottom: 0px;
            right: 0px;
            background-color: white;
            overflow: auto;
        }

        #scoreHeaderDiv {
            border-bottom: 2px solid black;
            height: 2em;
            margin-bottom: 1em;
            display: flex;
            align-items: center;
            padding-left: 0.3em;
        }

        #playerInputWarining {
            color: red;
            font-size: 0.85em;
            margin-left: 0.2em;
            display: none;
        }

        /* Table Styles */ 
        table {
            border-collapse: separate;
            border: 0px solid #808080;/*grayBackground*/		
            border-spacing: 0px 5px;
            margin: 0px 15px 15px 15px;
            width:98%;
        }

        tr:nth-child(even) {
            background-color: #E2E2ED;
        }
        tr:nth-child(even):hover {
            background-color: #D2D2ED;
        }
        tr:nth-child(odd) {
            background-color:#F2F2FD;
        }
        tr:nth-child(odd):hover {
            background-color:#E2E2FD;
        }

        th {
            color:#F2F2FD;/*lightBackground*/
            background-color:#505050;
            border-radius: 5px;
            box-shadow: 0px 3px 3px 0px #303030;
            padding: 2px 10px 0px 10px;
        }
        th.h {
            cursor: pointer;
        }

        td {
            padding: 2px 10px 0px 10px;
        }

        tr:nth-child(even).highlightedRow {
            background-color: hsl(209, 100%, 98%) !important;
        }
        tr:nth-child(even):hover.highlightedRow {
            background-color: hsl(209, 100%, 96%) !important;
        }
        tr:nth-child(odd).highlightedRow {
            background-color:hsl(209, 100%, 94%) !important;
        }
        tr:nth-child(odd):hover.highlightedRow {
            background-color:hsl(209, 100%, 92%) !important;
        }
    </style>

    <script type="text/javascript">
        document.addEventListener("DOMContentLoaded", function() { 
            // Version 4 2022-09


            // Canvas and context


            var c = getElem("canvas");
            var ctx = c.getContext("2d");
            ctx.save();
            var width = 1920;
            var height = 1080;

            const DegToRad = (Math.PI / 180.0);            


            // Render


            var viewportScale = 1.0;
            var viewportOffsetX = 0;
            var viewportOffsetY = 0;

            var canvasZoom = 1.0;
            var canvasOffsetX = 0;
            var canvasOffsetY = 0;


            // Events


            window.addEventListener("resize", resizeViewport);
            c.addEventListener("mousedown", canvasMouseDown);
           // c.addEventListener("touchstart", canvasTouchStart);
            c.addEventListener("mousemove", canvasMouseMove);
            c.addEventListener("mouseup", canvasMouseUp);
            c.addEventListener("wheel", canvasMouseWheel);
            c.addEventListener("mouseleave", canvasMouseLeave);
            

            // Inputs


            var newUserInput = 0;
            var userInput = 0;

            var currentX = 0;
            var currentY = 0;

            var lastX = 0;
            var lastY = 0;
          
            var cX = 0;
            var cY = 0;
            var lX = 0;
            var lY = 0;

            mouseDn0 = false;
            mouseDn1 = false;
            mouseDn2 = false;
            mouseDg0 = false;
            mouseDg1 = false;
            mouseDg2 = false;
            mouseUp0 = false;
            mouseUp1 = false;
            mouseUp2 = false;
            mouseW = 0;

            function canvasMouseDown(event) {
                if (event.button == 0) mouseDn0 = true;
                if (event.button == 1) mouseDn1 = true;
                if (event.button == 2) mouseDn2 = true;

                if (!audioContext) setAudio();
                if (event.preventDefault) { event.preventDefault(); };
                return false;
            }

     /*       function canvasTouchStart(event) {
                if (!audioContext) setAudio();
                var touch = event.changedTouches[0];
                currentX = (((touch.pageX - c.offsetLeft) / canvasZoom) - viewportOffsetX) / viewportScale;
                currentY = (((touch.pageY - c.offsetTop) / canvasZoom) - viewportOffsetY) / viewportScale;  
                cX = touch.pageX;
                cY = touch.pageY;
                canvasMouseDown({button: 0});
            }*/

            function canvasMouseMove(event) {
                currentX = (((event.pageX - c.offsetLeft) / canvasZoom) - viewportOffsetX) / viewportScale;
                currentY = (((event.pageY - c.offsetTop) / canvasZoom) - viewportOffsetY) / viewportScale;  
                cX = event.pageX;
                cY = event.pageY;
            }

            function canvasMouseUp(event) {
                if (event.button == 0) mouseUp0 = true;
                if (event.button == 1) mouseUp1 = true;
                if (event.button == 2) mouseUp2 = true;

                if (event.preventDefault) { event.preventDefault(); };
                return false;
            }
            function canvasMouseWheel(event) {   
                mouseW = (event.deltaY > 0) ? 1 : -1;
            }
            function canvasMouseLeave() {
                var lX = 0;
                var lY = 0;
                mouseDn0 = false;
                mouseDn1 = false;
                mouseDn2 = false;
                mouseDg0 = false;
                mouseDg1 = false;
                mouseDg2 = false;
                mouseUp0 = false;
                mouseUp1 = false;
                mouseUp2 = false;
                mouseW = 0;
            }


            // Viewport


            function resizeViewport() {
                width  = c.offsetWidth;
                height = c.offsetHeight;

                c.width  = width;
                c.height = height;

                // "view matrix"
                // largest size is +/- 1.0
                // other is AR proportionnal
                var ar = width / height;

                if (ar < 1.0) {
                    viewportScale = width;// / 2.0;
                    viewportOffsetX = viewportScale / 2.0;
                    viewportOffsetY = viewportScale / 2.0 / ar;
                } else {
                    viewportScale = height;// / 2.0;
                    viewportOffsetX = viewportScale / 2.0 * ar;
                    viewportOffsetY = viewportScale / 2.0;
                }
                globalViewScale = viewportScale / 1080;

                ctx.restore();
                ctx.translate(viewportOffsetX, viewportOffsetY);
                ctx.scale(viewportScale, viewportScale);
                ctx.save();

                resizeCanvas();
            }

            function resizeCanvas(f) {
                c.style.width =  (canvasZoom * 100) + "%";
                c.style.height = (canvasZoom * 100) + "%";

                c.style.top  = (canvasOffsetY - (c.parentElement.offsetHeight - c.height) / 2 ) + "px"; 
                c.style.left = (canvasOffsetX - (c.parentElement.offsetWidth  - c.width)  / 2 ) + "px";
            }


            // Helper Methods


            // Seeded RNG based on https://gist.github.com/blixt/f17b47c62508be59987b
            class Random {
                constructor(seed) {
                    this._seed = seed % 2147483647;
                    if (this._seed <= 0) this._seed += 2147483646;
                }
                // Returns a pseudo-random value between 1 and 2^32 - 2.
                next() {
                    return this._seed = this._seed * 16807 % 2147483647;
                }
                // Returns a pseudo-random floating point number in range [0.0, 1.0-epsilon].
                nextFloat() {        
                    return (this.next() - 1) / 2147483646; // We know that result of next() will be 1 to 2147483646 (inclusive).
                }
                // Returns a pseudo-random integer in range [0, maxInt-1].
                nextInt(maxInt) {
                    return Math.floor(maxInt * (this.next() - 1) / 2147483646);
                }
            }

            // Create rendered text from canvas to avoid canvas scale issues with font sizes
            function convertText(text, image, size = 48, color = "white") {
                var textCanvas = document.createElement("canvas");
                textCanvas.width = 512;
                textCanvas.height = size;
                var textContext = textCanvas.getContext("2d");
                textContext.font = size + "px Lucida Console";
                textContext.textAlign = "center";
                textContext.textBaseline = "middle";
                textContext.fillStyle = color;
                var textSize = textContext.measureText(text); 

                textCanvas.width = textSize.width*1.1;

                textContext.font = size + "px Lucida Console";
                textContext.textAlign = "center";
                textContext.textBaseline = "middle";
                textContext.fillStyle = color;

                textContext.fillText(text, textCanvas.width / 2, textCanvas.height / 2);

                textCanvas.toBlob(function(blob) {
                    //image = document.createElement('img');
                    url = URL.createObjectURL(blob);
                    image.onload = function() {
                        URL.revokeObjectURL(url);
                    };
                    image.src = url;
                });
            }

            // DOM
            function getElem(id) {
                var elem = document.getElementById(id);
                if (elem) return elem;
                return false;
            }
            function onClick(elemOrID, callback) {
                if (typeof(elemOrID) == "string") elemOrID = getElem(elemOrID);
                if (elemOrID) elemOrID.addEventListener("click", callback);
            }
            function parentID(elem) {
                while ((elem) && (!(elem.id))) {
                    elem = elem.parentElement;
                }
                return elem.id;
            }


            // Timing state


            var time = 0;
            var timeLast = 0;
            var timeDelta = 0;
            var timeScale = 1.0;
            var frame = 0;
            var frameInterval = 1; // update scene every "frameInterval" frames
            var run = true;


            // Audio Data


            var audioContext, gainNode;
            var b0, b1, b2, b3, bfail;
            var t0, t1, t2, t3, tfail;


            // Colors


            var fillStyles = [ 
                // red        yellow     green      blue
                ["#FF0000", "#FFFF00", "#00FC00", "#0017FF"], // off
                ["#FFF3DD", "#FFFFD2", "#E8FFE4", "#DEFFFF"]  // on
            ];
/*
              var fillStyles = [
                ["hsl(0, 100%, 40%)", "hsl(60, 100%, 40%)", "hsl(120, 100%, 40%)", "hsl(240, 100%, 40%)"], // "off"
                ["hsl(0, 100%, 80%)", "hsl(60, 100%, 80%)", "hsl(120, 100%, 80%)", "hsl(240, 100%, 80%)"]  // "on"
            ];
*/

/*
            generated with Tests/testColors.html
            using Oklab color space

            off l = 0.8 d = 0.5000
            on  l = 1.0 d = 0.0625

                ang   off    on
            r   45.0 FF0000 FFF3DD
            g  142.5 00FC00 E8FFE4
            b -112.5 0017FF DEFFFF
            y  106.0 D2C800 FFFFD2
*/


            // Images


            var checkImage = getElem("check");
            var crossImage = getElem("cross");
            var eyeImage = getElem("eye");
            var startImage = document.createElement('img');
            var newImage = document.createElement('img');
            var newHSImage = document.createElement('img');


            // Highscore panel elements and events


            var scoreButton = getElem('scoreButtonDiv');
            onClick(scoreButton, scoreButtonClick);
            var scoreDiv = getElem("scoreDiv");
            onClick("scoreCloseButton", closeScore);
            var tabButtons = document.querySelectorAll(".E3D_tabButton");
            tabButtons.forEach( (elem) => onClick(elem, scoreTabClick) );
            var tabs = document.querySelectorAll(".E3D_tabContent");
            onClick("playerSetButton", setPlayerName);
            var playernameInput = getElem("playernameInput");


            // Game State Data


            const GS_Idle = 0;
            const GS_Teach = 1;
            const GS_Recall = 2;
            const GS_Failed = 3;
            const GS_Success = 4;    
            const GS_Max = 4;   
            const GS_Strings = ["Idle", "Teach", "Recall", "Failed", "Success"];     
            var state = GS_Idle;

            function isGameActive() { return ((state == GS_Teach) || (state == GS_Recall)); }

            var currentLevel = 0;
            var currentStep = 0;
            var seq = [];
            var RNG_Sequence = new Random(666);
            var RNG_ColorShuffle = new Random(1337);

            var playerName = "<Player>";
            const name_regex = /^[\w#!\$%\?&\*\(\)@\-=_+,.~\{\}\[\]]{3,32}$/;
            // a-z A-Z 0-9 # ! $ % ? & * ( ) @ - = _ + , . ~ { } [ ]

            
            // Score data


            var currentScore = 0;
            var localHighScore = 0;
            var playerHighScore = 0;

            var newHS = false;
            var newHSobj;
            class scoreObject {
                constructor(n) {
                    this.version = 4;
                    this.timestamp = Date.now();
                    this.name = n;
                    this.score = currentScore;
                    this.level = currentLevel + 1;
                    this.step = currentStep;
                    this.CSM = colorShuffleMode;
                    this.SQTY = shuffleQty;
                    this.SSM = soundSuffleMode;
                }
            }


            // Timing and display


            var timeSinceLastHit = 0.0;
            const maxTimeBetweenHit = 1.5;
            var lastHitStartAngle = 0;
            var userInputDelay = 0;

            const teachDelayBase = 0.5;
            const teachDelayMin = 0.15;
            const teachDelayDecrements = 0.02;
            const successDelay = 1.25;
            const flashDelay = 0.1;


            // Shuffle


            const shuffleResetState = [0, 1, 2, 3];
            var shuffle = shuffleResetState.slice();


            // Color Shuffle Modes


            const CSM_None = 0;
            const CSM_BeforeTeach = 1;
            const CSM_AfterTeach = 2;
            const CSM_AfterEachRecalls = 3;
            const CSM_AfterEachTeach = 4;
            const CSM_Always = 5;
            const CSM_Max = 5;
            const CSM_Strings = ["None", "Level ★", "Recall ★★", "Input ★★★", "Teach ★★★★", "Always ★★★★★"]; //  ["None", "BeforeTeach", "AfterTeach", "AfterEachRecalls", "BeforeEachRecalls"];
            const CSM_ScoreMultipliers = [5, 10, 15, 20, 25, 30];
            var colorShuffleMode = CSM_None;
            var CSM_AfterEachTeach_Done = true;
            /*
            L: Colors shuffle at the begining of the level <br /> CSM_BeforeTeach
            R: Colors shuffle before the recall stage <br /> CSM_AfterTeach
            P: Colors shuffle after each player input in the recall stage <br /> CSM_AfterEachRecalls
            T: Colors shuffle after each color ligts up in the teaching stage <br /> CSM_AfterEachTeach
            E: Colors shuffle everytime after they light up. <hr /> CSM_Always
            */
            var shuffleQty = 2; // 2, 3 or 4


            // Sound Shuffle Modes


            const SSM_None = 0;
            const SSM_EachLevel = 1;
            const SSM_AfterTeach = 2;
            const SSM_Max = 2;
            const SSM_Strings = ["None", "Level ★", "Recall ★★"]; //  ["No Shuffle", "EachLevel", "AfterTeach"];
            const SSM_ScoreMultipliers = [5, 10, 15];
            var soundSuffleMode = SSM_None;
            var soundShuffle = shuffleResetState.slice();

            var status = getElem("statusSpan");
            var statusFormat = "Color Shuffle:$mode, Sound Suflle:$sound, Stage:$state, Level:$level, Step: $step";
            if ((status) && (status.innerText != "")) statusFormat = status.innerText;


            // UI event handlers


            // volume slider
            var volSlider = getElem("vol");
            if (localStorage) {
                var v = localStorage.getItem("m1.vol");
                if (v != undefined) {
                    volSlider.value = v;
                }
            }
            volSlider.addEventListener("input", function (event) { 
                if (gainNode) gainNode.gain.value = this.value; 
                if (localStorage) localStorage.setItem("m1.vol", this.value);
            });

            // shuffle mode button
            onClick("shuffleModeButton", function (event) {
                if (isGameActive()) return;
                colorShuffleMode++;
                if (colorShuffleMode > CSM_Max) colorShuffleMode = 0;
                if (localStorage) localStorage.setItem("m2.mode", colorShuffleMode);
            });
            if (localStorage) {
                var m = localStorage.getItem("m2.mode");
                if (m != undefined) {
                    colorShuffleMode = m;
                }
            }  

            // shuffle qty button
            onClick("shuffleQtyButton", function (event) {
                if (isGameActive()) return;
                shuffleQty++;
                if (shuffleQty > 4) shuffleQty = 2;
                if (localStorage) localStorage.setItem("m2.itt", shuffleQty);
            });   
            if (localStorage) {
                var i = localStorage.getItem("m2.itt");
                if (i != undefined) {
                    shuffleQty = i;
                    if (shuffleQty < 2) shuffleQty = 2;
                    if (shuffleQty > 4) shuffleQty = 4;
                }
            }

            // shuffle sound button
            onClick("shuffleSoundButton", function (event) {
                if (isGameActive()) return;
                soundSuffleMode++;
                if (soundSuffleMode > SSM_Max) soundSuffleMode = 0;
                if (localStorage) localStorage.setItem("m2.ssm", soundSuffleMode);
            });   
            if (localStorage) {
                var s = localStorage.getItem("m2.ssm");
                if (s != undefined) {
                    soundSuffleMode = s;
                }
            }
            // TODO FR - EN localization


            // Init


            resizeViewport();
            startLoop();
            convertText("Start Game", startImage);
            convertText("New Game", newImage);
            convertText("New High Score!", newHSImage, 36, "lime");
            loadHighscores();


            // Loop


            function startLoop() {
                window.requestAnimationFrame((startTime) => { 
                    timeLast = startTime; 
                    window.requestAnimationFrame(gameLoop); 
                } );
            }

            function gameLoop(t) {
                frame++;
                if ((frame % frameInterval) == 0) {
                    timeKeeping(t);
                    updateInputs();
                    if (run) {
                        updateScene();
                        drawScene();
                        cleanupScene();
                    }
                }
                window.requestAnimationFrame(gameLoop);
            }


            // Timing


            function timeKeeping(newTime) {
                timeDelta = ((newTime - timeLast) * timeScale) / 1000.0;
                if (run) time += timeDelta;
                timeLast = newTime;
            }


            // Inputs processing


            function updateInputs() {
                // handle mouse down
                if (mouseDn0) {
                    mouseDn0 = false;
                    mouseDg0 = true;

                    checkHitRegion(currentX, currentY);
                }
                if (mouseDn1) {
                    mouseDn1 = false;
                    mouseDg1 = true;
                    lX = cX;
                    lY = cY;
                }
                if (mouseDn2) {
                    mouseDn2 = false;
                    mouseDg2 = true;
                }

                // handle mouse up
                if (mouseUp0) {
                    mouseUp0 = false;
                    mouseDg0 = false;
                }                
                if (mouseUp1) {
                    mouseUp1 = false;
                    mouseDg1 = false;
                }                
                if (mouseUp2) {
                    mouseUp2 = false;
                    mouseDg2 = false;
                }

                // handle mouse drag
                if (mouseDg0) {
                    //
                }                
                if (mouseDg1) {
                  //  canvasOffsetX += cX - lX;
                   // canvasOffsetY += cY - lY;
                   // lX = cX;
                   // lY = cY;
                   // resizeCanvas();
                }                
                if (mouseDg2) {
                    //
                }

                if (mouseW < 0) {
                //    canvasZoom = canvasZoom * 1.25;
                    mouseW = 0;
                    resizeCanvas();
                }
                if (mouseW > 0) {
                 //   canvasZoom = canvasZoom / 1.25;
                    mouseW = 0;
                    resizeCanvas();
                }
            }

            function checkHitRegion(x, y) {
                if (state != GS_Teach) {
                    var d = Math.sqrt((x * x) + (y * y));
                    if ((d > 0.05) && (d < 0.40)) {
                        if ((x >  0.05) && (y >  0.05)) newUserInput = shuffle[0] + 1;
                        if ((x < -0.05) && (y >  0.05)) newUserInput = shuffle[1] + 1;
                        if ((x < -0.05) && (y < -0.05)) newUserInput = shuffle[2] + 1;
                        if ((x >  0.05) && (y < -0.05)) newUserInput = shuffle[3] + 1;
                    }
                    if ((x > -0.40) && (x < 0.40) && (y > -0.05) && (y < 0.05)) newUserInput = 5;
                }
            }


            // Game Methods

            
            // Audio

            function setAudio() {
                audioContext = new window.AudioContext();
                gainNode = audioContext.createGain();

                b0 = getElem("b0");
                var t0 = audioContext.createMediaElementSource(b0);
                t0.connect(gainNode).connect(audioContext.destination);

                b1 = getElem("b1");
                var t1 = audioContext.createMediaElementSource(b1);
                t1.connect(gainNode).connect(audioContext.destination);

                b2 = getElem("b2");
                var t2 = audioContext.createMediaElementSource(b2);
                t2.connect(gainNode).connect(audioContext.destination);

                b3 = getElem("b3");
                var t3 = audioContext.createMediaElementSource(b3);
                t3.connect(gainNode).connect(audioContext.destination);

                bfail = getElem("fail");
                var tfail = audioContext.createMediaElementSource(bfail);
                tfail.connect(gainNode).connect(audioContext.destination);
            }
            function playColor(index) {
                var i = soundShuffle[index - 1];
                if (audioContext) switch (i) {
                    case 0: b0.play(); break;
                    case 1: b1.play(); break;
                    case 2: b2.play(); break;
                    case 3: b3.play(); break;
                }
            }

            // Game state

            function fail() {
                state = GS_Failed;
                bfail.play();
                lastHitStartAngle = 0;

                if (currentScore > playerHighScore) {
                    playerHighScore = currentScore;
                    newHS = true;
                }
                if (currentScore > localHighScore)  {
                    localHighScore = currentScore;
                    newHS = true;
                }
                if (newHS) {
                    if (localStorage) localStorage.setItem("m3.hs", localHighScore);
                    newHSobj = new scoreObject(playerName);
                    var list = getHSlist();
                    list.push(newHSobj);
                    setHSlist(list);

                    scoreButton.style.backgroundColor = "lime";
                    playerInputWarining.style.display = (playerName != "<Player>") ? "none" : "";
                    if (playerName != "<Player>") postNewHS();
                }
            }

            function performShuffle() {
                // prep array
                var newPos = [];
                var possiblePos = [0, 1, 2, 3];                
                for (var i = 0; i < shuffleQty; ++i) newPos.push(possiblePos.splice(RNG_ColorShuffle.nextInt(possiblePos.length), 1)); 

                // variable length swap
                var b = shuffle[newPos[0]];
                for (var i = 0; i < shuffleQty - 1; ++i) shuffle[newPos[i]] = shuffle[newPos[i+1]];
                shuffle[newPos[shuffleQty - 1]] = b;
            }

            function performSoundShuffle() {
                // prep array
                var newPos = [];
                var possiblePos = [0, 1, 2, 3];                
                for (var i = 0; i < shuffleQty; ++i) newPos.push(possiblePos.splice(RNG_ColorShuffle.nextInt(possiblePos.length), 1)); 

                // variable length swap
                var b = soundShuffle[newPos[0]];
                for (var i = 0; i < shuffleQty - 1; ++i) soundShuffle[newPos[i]] = soundShuffle[newPos[i+1]];
                soundShuffle[newPos[shuffleQty - 1]] = b;
            }

            // Highscores

            function getHSlist() {
                if (localStorage) try {
                    let text = localStorage.getItem("m4.hsl");
                    if (text) {
                        let list = JSON.parse(text);
                        if (!list.length) throw Error("wtf");
                        return list;
                    }
                } catch (ex) { console.log(ex); }
                return [];
            }

            function setHSlist(list) {
                if (localStorage) try {
                    let text = JSON.stringify(list);
                    localStorage.setItem("m4.hsl", text);
                } catch (ex) { console.log(ex); }
            }

            function loadHighscores(){
                if (localStorage) {
                    var hs = localStorage.getItem("m3.hs");
                    if (hs != undefined) {
                        localHighScore = hs;
                    }
                    var pn = localStorage.getItem("m4.pn");
                    if ((pn !== undefined) && (pn !== null)) {
                        playerName = pn;
                        playernameInput.value = pn;
                    }
                    getPlayerHighScore();
                } 
            }

            function getPlayerHighScore() {
                if (playerName != "<Player>") {
                    let hsl = getHSlist();
                    for (var hs of hsl) if ((hs.name == playerName) && (hs.score > playerHighScore)) playerHighScore = hs.score;
                }
            }


            // Scene


            function updateScene() {            

                // inputs
                if ((newUserInput > 0) && (newUserInput < 5)) {
                    playColor(newUserInput);
                    lastHitStartAngle += (360 * timeSinceLastHit / maxTimeBetweenHit);
                    if (lastHitStartAngle > 360) lastHitStartAngle -= 360;
                    timeSinceLastHit = 0;
                    userInput = newUserInput;
                    userInputDelay = flashDelay;
                }


                // Game Logic 
                if (state == GS_Recall) {
                    if (timeSinceLastHit > maxTimeBetweenHit) {
                        fail();
                    } else if ((newUserInput > 0) && (newUserInput < 5)) {
                        if (newUserInput == seq[currentStep]) {
                            currentStep++;
                            if (currentStep > currentLevel) {
                                state = GS_Success;
                                stepDelayRemaining = successDelay;
                            }
                            currentScore += CSM_ScoreMultipliers[colorShuffleMode];
                            currentScore += SSM_ScoreMultipliers[soundSuffleMode];
                            currentScore += (shuffleQty - 2) * 2; // 2 3 4 -> 0 2 4
                            if (colorShuffleMode == CSM_AfterEachRecalls) performShuffle();
                            if (colorShuffleMode == CSM_Always) performShuffle();
                        } else fail();
                    }
 
                }
                if ((state == GS_Idle) || (state == GS_Failed)) {
                    if (newUserInput == 5) {
                        seq = [];
                        seq.push(RNG_Sequence.nextInt(4) + 1);
                        if (colorShuffleMode == CSM_BeforeTeach) performShuffle();
                        state =  GS_Teach;
                        currentLevel = 0;
                        currentStep = 0;
                        currentScore = 0;
                        newHS = false;
                        stepDelayRemaining = teachDelayBase;
                    } 
                }
                if (state == GS_Teach) {
                    stepDelayRemaining -= timeDelta;
                    if (stepDelayRemaining <= 0) {

                        if (currentStep > currentLevel) {
                            if (colorShuffleMode == CSM_AfterTeach) performShuffle();
                           // if (colorShuffleMode == CSM_Always) performShuffle();
                            if (soundSuffleMode == SSM_AfterTeach) performSoundShuffle();
                            state = GS_Recall;
                            timeSinceLastHit = 0;
                            currentStep = 0;
                        } else {                            
                            userInput = seq[currentStep];
                            userInputDelay = flashDelay;
                            //console.log("teach: " + newUserInput);
                            playColor(userInput);
                            currentStep++;
                            CSM_AfterEachTeach_Done = false;
                        } 

                        //reset delay
                        stepDelayRemaining = teachDelayBase - (teachDelayDecrements * currentLevel);
                        if (stepDelayRemaining < teachDelayMin) stepDelayRemaining = teachDelayMin;

                    } // delay reached
                    if ((stepDelayRemaining <= flashDelay * 2) && (!CSM_AfterEachTeach_Done)) {
                        if ((colorShuffleMode == CSM_AfterEachTeach) || (colorShuffleMode == CSM_Always)) {
                            performShuffle();
                            CSM_AfterEachTeach_Done = true;
                        }
                    }
                }// state teach

                if (state == GS_Success) {
                    stepDelayRemaining -= timeDelta;
                    if (stepDelayRemaining <= 0) {
                        currentStep = 0;
                        seq.push(RNG_Sequence.nextInt(4) + 1);
                        currentLevel++;
                        if (colorShuffleMode == CSM_BeforeTeach) performShuffle();
                        if (soundSuffleMode == SSM_EachLevel) performSoundShuffle();
                        state = GS_Teach;
                        stepDelayRemaining = teachDelayBase;
                    }
                }
            }

            function drawScene(){                
                // clear
                ctx.clearRect(-2, -2, 4, 4);
                clear = false;

                // text
                var txt = "";
                txt = statusFormat.replace("$mode", CSM_Strings[colorShuffleMode]);
                txt = txt.replace("$qty", (shuffleQty.toString()) + ( (shuffleQty > 2) ? (" " + "★".repeat(shuffleQty-2)) : "") );
                txt = txt.replace("$sound", SSM_Strings[soundSuffleMode]);
                txt = txt.replace("$state", GS_Strings[state]);
                txt = txt.replace("$level", currentLevel + 1);
                txt = txt.replace("$step", currentStep);
                txt = txt.replace("$score", currentScore);
                txt = txt.replace("$lhs", localHighScore);
                txt = txt.replace("$pn", playerName);
                txt = txt.replace("$phs", playerHighScore);
                status.innerText = txt;

                // grid
                ctx.setLineDash([]);
                ctx.strokeStyle = "#888";
                ctx.beginPath();
                for (var i = -15; i <= 15; ++i) {
                    line((i/10), -1.5, (i/10), 1.5);
                    line(-1.5, (i/10), 1.5, (i/10));
                }
                ctx.stroke();

                // origin
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 3.0 / viewportScale;
                ctx.setLineDash([20 / viewportScale, 3 / viewportScale, 3 / viewportScale, 3 / viewportScale]);
                ctx.beginPath();
                line( 0.0, -1.5, 0.0, 1.5);
                line(-1.5,  0.0, 1.5, 0.0);
                ctx.stroke();

                // draw objects
                ctx.setLineDash([]);
                ctx.lineWidth = 2.0 / viewportScale;

                // frame
                ctx.fillStyle = "black";
                arcFill(0, 0, 0.45, 0, 360);

                // buttons
                var flashIndex = (userInputDelay > 0) ? userInput : -1;
                ctx.fillStyle = fillStyles[flashIndex - 1 == shuffle[0] ? 1 : 0][shuffle[0]];
                arcFill(0.0, 0.0, 0.4, 0, 90);
                ctx.fillStyle = fillStyles[flashIndex - 1 == shuffle[1] ? 1 : 0][shuffle[1]];
                arcFill(0.0, 0.0, 0.4, 90, 180);
                ctx.fillStyle = fillStyles[flashIndex - 1 == shuffle[2] ? 1 : 0][shuffle[2]];
                arcFill(0.0, 0.0, 0.4, 180, 270);
                ctx.fillStyle = fillStyles[flashIndex - 1 == shuffle[3] ? 1 : 0][shuffle[3]];
                arcFill(0.0, 0.0, 0.4, 270, 0);

                ctx.fillStyle = "black";
                ctx.fillRect(-0.42, -0.05, 0.84, 0.1);
                ctx.fillRect(-0.05, -0.42, 0.1, 0.84);

                ctx.lineWidth = 1.0 / viewportScale;
                ctx.fillStyle = "white";

                if (state == GS_Idle) {
                    ctx.strokeStyle = "white";
                    ctx.strokeRect(-0.3, -0.04, 0.6, 0.08);
                    drawImageScaledCentered(startImage, 0.0, 0.0, 2.0);
                
                } else if (state == GS_Teach) {
                    drawImageScaledCentered(eyeImage, 0.0, 0.0, 0.6);
                    
                } else if (state == GS_Recall) {
                    var t = (maxTimeBetweenHit - timeSinceLastHit) / maxTimeBetweenHit;
                    var baseColor = 255 - (255 * t * t);
                    baseColor = Math.round(baseColor).toString(16).padStart(2, "0");
                    ctx.strokeStyle = "#" + baseColor + "" + baseColor + "" + baseColor;
                    ctx.lineWidth = 5.0 / viewportScale;
                    arcStroke(0, 0, 0.425, (360 * timeSinceLastHit / maxTimeBetweenHit) - 90 + lastHitStartAngle, 270 + lastHitStartAngle);
                    ctx.lineWidth = 1.0 / viewportScale;

                } else if (state == GS_Failed) {
                    drawImageScaledCentered(crossImage, 0.0, 0.0, 0.4);
                    ctx.strokeStyle = "white";
                    ctx.strokeRect(0.06, -0.04, 0.34, 0.08);
                    drawImageScaledCentered(newImage, 0.23, 0.0, 1.4);
                    if (newHS) drawImageScaledCentered(newHSImage, -0.23, 0.0, 1.25);
                } else if (state == GS_Success) {
                    drawImageScaledCentered(checkImage, 0.0, 0.0, 0.4);
                }
            }

            function cleanupScene(){
                lastX = currentX;
                lastY = currentY;
                lastT = time;
                newUserInput = 0;
                timeSinceLastHit += timeDelta;
                userInputDelay -= timeDelta;
            }


            // Context drawing methods


            function line(x1, y1, x2, y2) {
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
            }
            function circleFill(x, y, r) {
                ctx.beginPath();
                ctx.arc(x,
                        y,
                        r,
                        0,
                        Math.PI * 2.0);
                ctx.fill();
            }
            function circleStroke(x, y, r) {
                ctx.beginPath();
                ctx.arc(x,
                        y,
                        r,
                        0,
                        Math.PI * 2.0);
                ctx.stroke();
            }
            function arcFill(x, y, r, startAngle, endAngle) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.arc(x,
                        y,
                        r, 
                        startAngle * DegToRad, 
                        endAngle * DegToRad);
                ctx.lineTo(x, y);
                ctx.fill();
            }

            function arcStroke(x, y, r, startAngle, endAngle) {
                ctx.moveTo(x, y);
                ctx.beginPath();
                ctx.arc(x,
                        y,
                        r,
                        startAngle * DegToRad,
                        endAngle * DegToRad);
                ctx.stroke();
            }
            function drawImageScaledCentered(img, x, y, scale = 1.0) {
                var w = img.width * scale;
                var h = img.height * scale;
                w = w / viewportScale * globalViewScale;
                h = h / viewportScale * globalViewScale;
                ctx.drawImage(img, x - (w / 2), y - (h / 2), w, h);
            }


            // ScoreBoard management methods


            function scoreButtonClick(event) {
                run = false;
                scoreDiv.style.visibility = "visible";
                tabButtons[0].click();
                scoreButton.style.backgroundColor = "";
            }

            function scoreTabClick(event) {
                tabButtons.forEach( (btn) => btn.classList.remove("E3D_tabButtonActive") );
                event.target.classList.add("E3D_tabButtonActive");
                tabs.forEach( (tab) => tab.style.display = "none");
                getElem(event.target.id + "Content").style.display = "block";
                if (event.target.id == "local") genLocalScores(); else genGlobalScores();
            }

            function closeScore(event) {
                scoreDiv.style.visibility = "hidden";
                setTimeout(() => run = true, 1000);
            }
            function setPlayerName(event) {
                const name_regex = /^[\w#!\$%\?&\*\(\)@\-=_+,.~\{\}\[\]]{3,32}$/;
                if (name_regex.test(playernameInput.value)) {
                    playerInputWarining.style.display = "none";
                    playerName = playernameInput.value;
                    if (localStorage) localStorage.setItem("m4.pn", playerName);
                    getPlayerHighScore();
                    if (newHS) postNewHS();
                } else {
                    playerInputWarining.innerText = "Invalid name, must be 3 to 32 characters long,\n can only contain: a-z A-Z 0-9 # ! $ % ? & * ( ) @ - = _ + , . ~ { } [ ]";
                }
            }

            function postNewHS() {
                console.log("uploading new HS");
                newHS = false;

                var httpRequest = new XMLHttpRequest();  

                httpRequest.onerror = function(event) {
                    console.log("upload error " + event.target.status + "\n" + event.target.responseText);
                }

                httpRequest.onloadend = function(event) {
                    console.log("upload done " + event.target.status + "\n" + event.target.responseText);
                }
                httpRequest.open("POST", "https://api.m4nusky.com/Memory/v4");
                let payload = {
                    "version":"4",
                    "op": "add",
                    "name": newHSobj.name,
                    "score": newHSobj.score,
                    "level": newHSobj.level,
                    "step": newHSobj.step,
                    "SQTY": newHSobj.SQTY,
                    "CSM": newHSobj.CSM,
                    "SSM": newHSobj.SSM
                }

                httpRequest.send(JSON.stringify(payload));
            }

            const localContentTab = getElem("localContent");
            const globalContentTab = getElem("globalContent");
            var _LastGlobalList = [];
            var _LastGlobalFetch = 0;

            function genLocalScores() {                
                var list = getHSlist();
                localContentTab.innerHTML = genScoreTable(list, byScore);
            }

            function genGlobalScores() {
                if ((Date.now() - _LastGlobalFetch) < 1000 * 60) return; // throttle to 1 per minute
                
                globalContentTab.innerText = "Fetching global score list...";
                var httpRequest = new XMLHttpRequest();

                httpRequest.onerror = function(event) {
                    console.log("Status: " + event.target.status);
                    globalContentTab.innerText = "Error getting global score list:\n" + event.target.responseText;
                }
                httpRequest.ontimeout = httpRequest.onerror;

                httpRequest.onloadend = function(event) {
                    console.log("Status: " + event.target.status);
                    if (event.target.status != 200) {
                        globalContentTab.innerText = "Error getting global score list"; 
                        console.log(event.target.responseText);
                        return; 
                    }
                    var list = event.target.responseText;
                    try {
                        list = JSON.parse(list);
                        if (list.status != "ok") {
                            globalContentTab.innerText = "Error parsing global score list:\nstatus = " + list.status;
                            console.log(list.body);
                            return;
                        }
                        list = list.body;
                        _LastGlobalList = list.slice();
                    } catch (ex) {
                        globalContentTab.innerText = "Error parsing global score list:\n" + ex.message;
                        return;
                    }
                    globalContentTab.innerHTML = genScoreTable(list, byScore);
                }

                httpRequest.open("POST", "https://api.m4nusky.com/Memory/v4");
                httpRequest.send('{"version":"4","op":"global"}');
                _LastGlobalFetch = Date.now();
            }


            const scoreTableHeader = '<table><tr><th class="h" onClick="sortTable(this, byName)">Player</th><th class="h" onClick="sortTable(this, byScore)">Score</th><th class="h" onClick="sortTable(this, byLevel)">Level</th><th>Step</th><th class="h" onClick="sortTable(this, byCSM)">Color Shuffle</th><th class="h" onClick="sortTable(this, bySQTY)">Shuffle Qty</th><th class="h" onClick="sortTable(this, bySSM)">Sound Shuffle</th><th class="h" onClick="sortTable(this, byDate)">Date</th></tr>';
            const scoreRowFormat = '<tr$class><td>$name</td><td>$score</td><td>$level</td><td>$step</td><td>$CSM</td><td>$qty</td><td>$SSM</td><td>$date</td></tr>';
            function genScoreTable(list, sortFunction) {
                let newHTML = scoreTableHeader.slice();
                list = list.sort(sortFunction);
                for (var score of list) {
                    newHTML += scoreRowFormat.replace("$name", score.name);
                    newHTML = newHTML.replace("$CSM", CSM_Strings[score.CSM]);
                    newHTML = newHTML.replace("$qty", (score.SQTY.toString()) + ( (score.SQTY > 2) ? (" " + "★".repeat(score.SQTY-2)) : "") );
                    newHTML = newHTML.replace("$SSM", SSM_Strings[score.SSM]);
                    newHTML = newHTML.replace("$level", score.level + 1);
                    newHTML = newHTML.replace("$step", score.step);
                    newHTML = newHTML.replace("$score", score.score);
                    newHTML = newHTML.replace("$date", formatDate(new Date(score.timestamp)));
                    newHTML = newHTML.replace("$class", (score.name == playerName) ? ' class="highlightedRow"' : "");
                }
                newHTML += "</table>";
                return newHTML;
            }

            function formatDate(d) {
                return d.getFullYear() + "/" + (""+(d.getMonth() + 1)).padStart(2, "0") + "/" + ("" + d.getDate()).padStart(2, "0") + " " + ("" + d.getHours()).padStart(2, "0") + ":" + ("" + d.getMinutes()).padStart(2, "0") + ":" + ("" + d.getSeconds()).padStart(2, "0");
            }


            // Global format and sort functions


            window.byScore = function(a, b) {
                const as = Number(a.score)
                const bs = Number(b.score);
                if (as != bs) return bs - as;
                return Number(b.timestamp) - Number(a.timestamp);
            }
            window.byDate = function(a, b) {
                return Number(b.timestamp) - Number(a.timestamp);
            }
            window.byName = function(a, b) {
                if (a.name == b.name) return (byScore(a, b));
                if (b.name < a.name) return  1;
                if (b.name > a.name) return -1;
            }
            window.byLevel = function(a, b) {
                if (a.level == b.level) return (byScore(a, b));
                return (b.level - a.level);
            }
            window.byCSM = function(a, b) {
                if (a.CSM == b.CSM) return (byScore(a, b));
                return (b.CSM - a.CSM);
            }
            window.bySQTY = function(a, b) {
                if (a.SQTY == b.SQTY) return (byScore(a, b));
                return (b.SQTY - a.SQTY);
            }
            window.bySSM = function(a, b) {
                if (a.SSM == b.SSM) return (byScore(a, b));
                return (b.SSM - a.SSM);
            }
            window.sortTable = function(context, sortFunction) {
                var id = parentID(context);
                if (id == "localContent") {
                    var list = getHSlist();
                    localContentTab.innerHTML = genScoreTable(list, sortFunction);
                } else {
                    var list = getHSlist();
                    globalContentTab.innerHTML = genScoreTable(_LastGlobalList, sortFunction);
                }
            }


            // EOS
        } );

    </script>
</head>

<body>
    <div class="E3D_fullscreenContainer E3D_flexVertical">
        <div id="scoreDiv">
            <div id="scoreHeaderDiv">
            <span> Player Name: <input type="text" id="playernameInput" value="&lt;Player&gt;" /><span id="playerSetButton" class="E3D_fakeButton">Set</span></span><span id="playerInputWarining">Set player name to allow global rankings participation</span> <span id="scoreCloseButton" class="E3D_fakeButton">Close</span>
        </div>
            <span class="E3D_tabButton" id="local">Local Scores</span><span class="E3D_tabButton" id="global">Global Scores</span>
            <div class="E3D_tabContent" id="localContent">
                Local Score list
            </div>
            <div class="E3D_tabContent" id="globalContent">
                Global Score list
            </div>
        </div>

        <div id="statusDiv" class="E3D_flexVerticalContentFit">
            <span id="statusSpan" class="E3D_monospaceText">Color Shuffle: $mode, Qty: $qty, Sound Suflle: $sound, Stage: $state
Level: $level, Step: $step
Score: $score, HighScore(local): $lhs, Player: $pn, Highscore(Player): $phs</span>
        </div>     

        <div class="E3D_flexContent">
            <canvas id="canvas" width="192" height="108">Canvas</canvas>

            <div id="volDiv">
                <span id="volSpan">Volume:</span>
                <input id="vol" type="range" min="0" max="2" value="1" step="0.1" />
                <div id="shuffleModeButton" class="E3D_fakeButton">Shuffle Mode</div>
                <div id="shuffleQtyButton" class="E3D_fakeButton">Shuffle Qty.</div>
                <div id="shuffleSoundButton" class="E3D_fakeButton">Sound Shuffle</div>
                <div id="toggleLangButton" class="E3D_fakeButton">EN/FR</div>
            </div>

            <div id="scoreButtonDiv">
                <img src="media/Score.svg" width="50" height="50" /></img><br />
            </div>
        </div>

        <div id="helpDiv" class="hoverSize">
            <img id="help" src="media/Help.svg" width="50" height="50" /></img><br />
            [EN]: <br />
            Learn the color pattern and repeat it to advance to the next level. Changing shuffle modes and quantity increase the score reward!<hr />
            Shuffle Modes: <br />
            None: Colors stay at the same place <br />
            Level: Shuffle at the begining of the level <br />
            Recall: Shuffle before the recall stage <br />
            Input: Shuffle after each player input in the recall stage <br />
            Teach: Colors shuffle after each color ligts up in the teaching stage <br />
            Always: Shuffle everytime after they light up. <hr />
            Shuffle QTY:<br />
            Number of colors that get shuffled.<hr />
            Sound Suffle:<br />
            Association of sounds and colors<br />    
            None: Sounds vs colors stay the same<br />
            Level: Shuffle at the begining of the level <br />
            Recall: Shuffle before the recall stage <br />
        </div>

    </div>

    <div id="hiddenMedia">
        <!-- SFX made with sfxr - sound effect generator -->
        <audio id="b0" src="media/Beep0.wav"></audio>
        <audio id="b1" src="media/Beep1.wav"></audio>
        <audio id="b2" src="media/Beep2.wav"></audio>
        <audio id="b3" src="media/Beep3.wav"></audio>
        <audio id="fail" src="media/Fail.wav"></audio>
        <!-- SVG made with https://editor.method.ac/ -->
        <img id="check" src="media/Check.svg"></img>
        <img id="cross" src="media/Cross.svg"></img>
        <img id="eye" src="media/Eye.svg"></img>
        <img id="score" src="media/Score.svg"></img>
    </div>
    
</body>

</html>
