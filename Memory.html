<!DOCTYPE html>
<html>
<head>
    <title>Memory Game 2</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="media/memory.ico">
    <style>
        body {
            margin: 0px;
            font-size: 18px;
            font-family: Arial, Helvetica, sans-serif;
        }        
        canvas {
            width: 100%;
            height: 100%;
            z-index: 0;
            position: relative;
        }
        #hiddenMedia {
            display: none;
        }
        .E3D_fullscreenContainer {
            position:fixed;
            top:0px;
            bottom:0px;
            right:0px;
            left:0px;
        }
        .E3D_margin {
            margin: 0.25em;
        }
        .E3D_fakeButton {
            cursor: pointer;
            background-color: #d0d0d0;   
            padding-right: 0.2em;
            padding-left: 0.2em;   
            user-select: none;   
            box-shadow: 0.1em 0.1em black;      
            border-radius: 0.2em; 
            margin: 0.1em 0.2em 0.2em 0.2em;
        }
        .E3D_fakeButton:hover {
            background-color: #a0a0a0;
        }
        .E3D_flexContent {
            overflow: hidden;
            flex: 1 1 auto;
        }
        .E3D_flexVertical {
            display: flex;
            flex-direction: column;
        }
        .E3D_flexVerticalContentFit {
            width: 100%;
            height: fit-content;
        }
        .E3D_monospaceText {
            white-space: pre-wrap;
            font-family: 'Courier New', Courier, monospace;
        }
        #log {
           z-index: 10;
            position: absolute;
            display: inline-block;
            padding: 5px;
            border-radius: 5px;
            border: 2px solid black;
            margin: 2px;
            background-color: white;
        }
        #helpDiv {
            z-index: 10;
            position: absolute;
            bottom: 0px;
            left: 0px;
            padding: 5px;
            border-radius: 5px;
            border: 2px solid black;
            margin: 2px;
            overflow: hidden;
            background-color: white;
        }
        #volDiv {
            z-index: 10;
            position: absolute;
            display: inline-block;
            right: 0px;
            text-align: center;
            border-radius: 5px;
            border: 2px solid black;
            margin: 2px;
            background-color: white;
        }
        #volSpan {
            display: block;             
        }
        .hoverSize {
            max-width: 50px;
            max-height: 50px;
            background-color: rgba(255, 255, 255, 0.25);

            transition: all 0.1s linear;
        }      
        .hoverSize:hover{
            max-width: 500px;
            max-height: 500px; /* should be equal to max-width to avoid transition overshoot */
            background-color: rgba(255, 255, 255, 0.95);
        }
        #statusDiv {
            z-index: 10;
        }

    </style>

    <script type="text/javascript">
        document.addEventListener("DOMContentLoaded", function() { 

            var c = document.getElementById("canvas");
            var ctx = c.getContext("2d");
            ctx.save();
            var width = 1920;
            var height = 1080;

            const DegToRad = (Math.PI / 180.0);

            // Render
            var viewportScale = 1.0;
            var viewportOffsetX = 0;
            var viewportOffsetY = 0;

            var canvasZoom = 1.0;
            var canvasOffsetX = 0;
            var canvasOffsetY = 0;

            // Events
            window.addEventListener("resize", resizeViewport);
            c.addEventListener("mousedown", canvasMouseDown);
           // c.addEventListener("touchstart", canvasTouchStart);
            c.addEventListener("mousemove", canvasMouseMove);
            c.addEventListener("mouseup", canvasMouseUp);
            c.addEventListener("wheel", canvasMouseWheel);
            c.addEventListener("mouseleave", canvasMouseLeave);
            document.addEventListener("keydown", canvasKeyDown);
            
            // Inputs
            var newUserInput = 0;
            var userInput = 0;

            var currentX = 0;
            var currentY = 0;

            var lastX = 0;
            var lastY = 0;
          
            var cX = 0;
            var cY = 0;
            var lX = 0;
            var lY = 0;

            mouseDn0 = false;
            mouseDn1 = false;
            mouseDn2 = false;
            mouseDg0 = false;
            mouseDg1 = false;
            mouseDg2 = false;
            mouseUp0 = false;
            mouseUp1 = false;
            mouseUp2 = false;
            mouseW = 0;

            function canvasMouseDown(event) {
                if (event.button == 0) mouseDn0 = true;
                if (event.button == 1) mouseDn1 = true;
                if (event.button == 2) mouseDn2 = true;

                if (!audioContext) setAudio();
                if (event.preventDefault) { event.preventDefault(); };
                return false;
            }

     /*       function canvasTouchStart(event) {
                if (!audioContext) setAudio();
                var touch = event.changedTouches[0];
                currentX = (((touch.pageX - c.offsetLeft) / canvasZoom) - viewportOffsetX) / viewportScale;
                currentY = (((touch.pageY - c.offsetTop) / canvasZoom) - viewportOffsetY) / viewportScale;  
                cX = touch.pageX;
                cY = touch.pageY;
                canvasMouseDown({button: 0});
            }*/

            function canvasMouseMove(event) {
                currentX = (((event.pageX - c.offsetLeft) / canvasZoom) - viewportOffsetX) / viewportScale;
                currentY = (((event.pageY - c.offsetTop) / canvasZoom) - viewportOffsetY) / viewportScale;  
                cX = event.pageX;
                cY = event.pageY;
            }

            function canvasMouseUp(event) {
                if (event.button == 0) mouseUp0 = true;
                if (event.button == 1) mouseUp1 = true;
                if (event.button == 2) mouseUp2 = true;

                if (event.preventDefault) { event.preventDefault(); };
                return false;
            }
            function canvasMouseWheel(event) {   
                mouseW = (event.deltaY > 0) ? 1 : -1;
            }
            function canvasMouseLeave() {
                var lX = 0;
                var lY = 0;
                mouseDn0 = false;
                mouseDn1 = false;
                mouseDn2 = false;
                mouseDg0 = false;
                mouseDg1 = false;
                mouseDg2 = false;
                mouseUp0 = false;
                mouseUp1 = false;
                mouseUp2 = false;
                mouseW = 0;
            }

            function canvasKeyDown(event) {
                // Debug state override
                if (event.key == "i") state = GS_Idle;
                if (event.key == "f") state = GS_Failed;
                if (event.key == "t") state = GS_Teach;
                if (event.key == "r") state = GS_Recall;
                if (event.key == "s") state = GS_Success;
                if (event.key == "x") performShuffle();
                timeSinceLastHit = 0;
                stepDelayRemaining = 1.0;
            }

            function resizeViewport() {
                width  = c.offsetWidth;
                height = c.offsetHeight;

                c.width  = width;
                c.height = height;

                // "view matrix"
                // largest size is +/- 1.0
                // other is AR proportionnal
                var ar = width / height;

                if (ar > 1.0) {
                    var s = width / 2.0;
                    viewportScale = width / 2.0;
                    viewportOffsetX = viewportScale;
                    viewportOffsetY = viewportScale / ar;
                } else {
                    viewportScale = height / 2.0;
                    viewportOffsetX = viewportScale * ar;
                    viewportOffsetY = viewportScale;
                }
                globalViewScale = viewportScale / 1080;

                ctx.restore();
                ctx.translate(viewportOffsetX, viewportOffsetY);
                ctx.scale(viewportScale, viewportScale);
                ctx.save();

                resizeCanvas();
            }

            function resizeCanvas(f) {
                c.style.width =  (canvasZoom * 100) + "%";
                c.style.height = (canvasZoom * 100) + "%";

                c.style.top  = (canvasOffsetY - (c.parentElement.offsetHeight - c.height) / 2 ) + "px"; 
                c.style.left = (canvasOffsetX - (c.parentElement.offsetWidth  - c.width)  / 2 ) + "px";
            }




            // Helper Methods

            // Seeded RNG based on https://gist.github.com/blixt/f17b47c62508be59987b
            class Random {
                constructor(seed) {
                    this._seed = seed % 2147483647;
                    if (this._seed <= 0) this._seed += 2147483646;
                }
                // Returns a pseudo-random value between 1 and 2^32 - 2.
                next() {
                    return this._seed = this._seed * 16807 % 2147483647;
                }
                // Returns a pseudo-random floating point number in range [0.0, 1.0-epsilon].
                nextFloat() {        
                    return (this.next() - 1) / 2147483646; // We know that result of next() will be 1 to 2147483646 (inclusive).
                }
                // Returns a pseudo-random integer in range [0, maxInt-1].
                nextInt(maxInt) {
                    return Math.floor(maxInt * (this.next() - 1) / 2147483646);
                }
            }
            function getElem(id) {
                var elem = document.getElementById(id);
                if (elem) return elem;
                return false;
            }





            // Debug data
            var strList = new Map();     

            // Timing
            var time = 0;
            var timeLast = 0;
            var timeDelta = 0;
            var timeScale = 1.0;
            var frame = 0;
            var frameInterval = 1; // update scene every "frameInterval" frames
            var run = true;

            // Audio Stuff
            var audioContext, gainNode;
            var b0, b1, b2, b3, bfail;
            var t0, t1, t2, t3, tfail;

            // Colors  240 120 60 0
            var fillStyles = [
                ["hsl(0, 100%, 40%)", "hsl(60, 100%, 40%)", "hsl(120, 100%, 40%)", "hsl(240, 100%, 40%)"], // "off"
                ["hsl(0, 100%, 80%)", "hsl(60, 100%, 80%)", "hsl(120, 100%, 80%)", "hsl(240, 100%, 80%)"]  // "on"
            ];

            // Images
            var checkImage = getElem("check");
            var crossImage = getElem("cross");
            var eyeImage = getElem("eye");
            var startImage = document.createElement('img');
            var newImage = document.createElement('img');

            // Game States
            const GS_Idle = 0;
            const GS_Teach = 1;
            const GS_Recall = 2;
            const GS_Failed = 3;
            const GS_Success = 4;    
            const GS_Max = 4;   
            const GS_Strings = ["Idle", "Teach", "Recall", "Failed", "Success"];     
            var state = GS_Idle;

            function isGameActive() { return ((state == GS_Teach) || (state == GS_Recall)); }

            var currentLevel = 0;
            var currentStep = 0;
            var seq = [];
            var RNG_Sequence = new Random(666);
            var RNG_ColorShuffle = new Random(1337);

            var timeSinceLastHit = 0.0;
            const maxTimeBetweenHit = 1.5;
            var lastHitStartAngle = 0;
            var userInputDelay = 0;

            const teachDelayBase = 0.5;
            const teachDelayMin = 0.15;
            const teachDelayDecrements = 0.02;
            const successDelay = 1.25;
            const flashDelay = 0.1;

            // Shuffle
            const shuffleResetState = [0, 1, 2, 3];
            var shuffle = shuffleResetState.slice();

            // Color Shuffle Modes
            const CSM_None = 0;
            const CSM_BeforeTeach = 1;
            const CSM_AfterTeach = 2;
            const CSM_AfterEachRecalls = 3;
            const CSM_BeforeEachRecalls = 4;
            const CSM_Max = 4;
            const CSM_Strings = ["None", "BeforeTeach", "AfterTeach", "AfterEachRecalls", "BeforeEachRecalls"];
            var colorShuffleMode = CSM_None;
            var shuffleQty = 2; // 2, 3 or 4

            // Sound Shuffle Modes
            const SSM_None = 0;
            const SSM_EachLevel = 1;
            const SSM_AfterTeach = 2;
            const SSM_Max = 2;
            const SSM_Strings = ["No Shuffle", "EachLevel", "AfterTeach"];
            var soundSuffleMode = SSM_None;
            var soundShuffle = shuffleResetState.slice();






            // UI event handlers

            // volume slider
            var volSlider = getElem("vol");
            if (window.localStorage) {
                var v = window.localStorage.getItem("m1.vol");
                if (v != undefined) {
                    volSlider.value = v;
                }
            }
            volSlider.addEventListener("input", function (event) { 
                if (gainNode) gainNode.gain.value = this.value; 
                if (window.localStorage) window.localStorage.setItem("m1.vol", this.value);
            });

            // shuffle mode button
            getElem("shuffleModeButton").addEventListener("click", function (event) {
                if (isGameActive()) return;
                colorShuffleMode++;
                if (colorShuffleMode > CSM_Max) colorShuffleMode = 0;
                if (window.localStorage) window.localStorage.setItem("m2.mode", colorShuffleMode);
            });
            if (window.localStorage) {
                var m = window.localStorage.getItem("m2.mode");
                if (m != undefined) {
                    colorShuffleMode = m;
                }
            }  

            // shuffle qty button
            getElem("shuffleQtyButton").addEventListener("click", function (event) {
                if (isGameActive()) return;
                shuffleQty++;
                if (shuffleQty > 4) shuffleQty = 2;
                if (window.localStorage) window.localStorage.setItem("m2.itt", shuffleQty);
            });   
            if (window.localStorage) {
                var i = window.localStorage.getItem("m2.itt");
                if (i != undefined) {
                    shuffleQty = i;
                    if (shuffleQty < 2) shuffleQty = 2;
                    if (shuffleQty > 4) shuffleQty = 4;
                }
            }

            // shuffle sound button
            getElem("shuffleSoundButton").addEventListener("click", function (event) {
                if (isGameActive()) return;
                soundSuffleMode++;
                if (soundSuffleMode > SSM_Max) soundSuffleMode = 0;
                if (window.localStorage) window.localStorage.setItem("m2.ssm", soundSuffleMode);
            });   
            if (window.localStorage) {
                var s = window.localStorage.getItem("m2.ssm");
                if (s != undefined) {
                    soundSuffleMode = s;
                }
            }   




            // Create rendered text from canvas to avoid canvas scale issues with font sizes
            function convertText(text, image) {
                var textCanvas = document.createElement("canvas");
                textCanvas.width = 512;
                textCanvas.height = 48;
                var textContext = textCanvas.getContext("2d");
                textContext.font = "48px Lucida Console";
                textContext.textAlign = "center";
                textContext.textBaseline = "middle";
                textContext.fillStyle = "white";
                var textSize = textContext.measureText(text); 

                textCanvas.width = textSize.width*1.1;

                textContext.font = "48px Lucida Console";
                textContext.textAlign = "center";
                textContext.textBaseline = "middle";
                textContext.fillStyle = "white";

                textContext.fillText(text, textCanvas.width / 2, textCanvas.height / 2);

                textCanvas.toBlob(function(blob) {
                    //image = document.createElement('img');
                    url = URL.createObjectURL(blob);
                    image.onload = function() {
                        URL.revokeObjectURL(url);
                    };
                    image.src = url;
                });
            }

            // Generate colors with same luminance
            function getLum(R, G, B) {
                return (0.2126 * R) + (0.7152 * G) + (0.722 * B);
            }

        


            // Init
            resizeViewport();
            startLoop();
            convertText("Start Game", startImage);
            convertText("New Game", newImage);

            // Loop
            function startLoop() {
                window.requestAnimationFrame((startTime) => { 
                    timeLast = startTime; 
                    window.requestAnimationFrame(gameLoop); 
                } );
            }

            function gameLoop(t) {
                frame++;
                if ((frame % frameInterval) == 0) {
                    timeKeeping(t);
                    updateInputs();
                    if (run) {
                        updateScene();
                        drawScene();
                        cleanupScene();
                    }
                }
                window.requestAnimationFrame(gameLoop);
            }

            // Timing
            function timeKeeping(newTime) {
                timeDelta = ((newTime - timeLast) * timeScale) / 1000.0;
                if (run) time += timeDelta;
                timeLast = newTime;
            }

            // Inputs processing
            function updateInputs() {
                // handle mouse down
                if (mouseDn0) {
                    mouseDn0 = false;
                    mouseDg0 = true;

                    checkHitRegion(currentX, currentY);
                }
                if (mouseDn1) {
                    mouseDn1 = false;
                    mouseDg1 = true;
                    lX = cX;
                    lY = cY;
                }
                if (mouseDn2) {
                    mouseDn2 = false;
                    mouseDg2 = true;
                }

                // handle mouse up
                if (mouseUp0) {
                    mouseUp0 = false;
                    mouseDg0 = false;
                }                
                if (mouseUp1) {
                    mouseUp1 = false;
                    mouseDg1 = false;
                }                
                if (mouseUp2) {
                    mouseUp2 = false;
                    mouseDg2 = false;
                }

                // handle mouse drag
                if (mouseDg0) {
                    //
                }                
                if (mouseDg1) {
                  //  canvasOffsetX += cX - lX;
                   // canvasOffsetY += cY - lY;
                   // lX = cX;
                   // lY = cY;
                   // resizeCanvas();
                }                
                if (mouseDg2) {
                    //
                }

                if (mouseW < 0) {
                //    canvasZoom = canvasZoom * 1.25;
                    mouseW = 0;
                    resizeCanvas();
                }
                if (mouseW > 0) {
                 //   canvasZoom = canvasZoom / 1.25;
                    mouseW = 0;
                    resizeCanvas();
                }
            }

            function checkHitRegion(x, y) {
                //strList.set("X", x.toFixed(3));
                //strList.set("Y", y.toFixed(3));

                if (state != GS_Teach) {
                    var d = Math.sqrt((x * x) + (y * y));
                    if ((d > 0.05) && (d < 0.40)) {
                        if ((x >  0.05) && (y >  0.05)) newUserInput = shuffle[0] + 1;
                        if ((x < -0.05) && (y >  0.05)) newUserInput = shuffle[1] + 1;
                        if ((x < -0.05) && (y < -0.05)) newUserInput = shuffle[2] + 1;
                        if ((x >  0.05) && (y < -0.05)) newUserInput = shuffle[3] + 1;
                    }
                    if ((x > -0.40) && (x < 0.40) && (y > -0.05) && (y < 0.05)) newUserInput = 5;
                }
            }





            // Methods
            
            function setAudio() {
                audioContext = new window.AudioContext();
                gainNode = audioContext.createGain();

                b0 = getElem("b0");
                var t0 = audioContext.createMediaElementSource(b0);
                t0.connect(gainNode).connect(audioContext.destination);

                b1 = getElem("b1");
                var t1 = audioContext.createMediaElementSource(b1);
                t1.connect(gainNode).connect(audioContext.destination);

                b2 = getElem("b2");
                var t2 = audioContext.createMediaElementSource(b2);
                t2.connect(gainNode).connect(audioContext.destination);

                b3 = getElem("b3");
                var t3 = audioContext.createMediaElementSource(b3);
                t3.connect(gainNode).connect(audioContext.destination);

                bfail = getElem("fail");
                var tfail = audioContext.createMediaElementSource(bfail);
                tfail.connect(gainNode).connect(audioContext.destination);
            }
            function playColor(index) {
                var i = soundShuffle[index - 1];
                if (audioContext) switch (i) {
                    case 0: b0.play(); break;
                    case 1: b1.play(); break;
                    case 2: b2.play(); break;
                    case 3: b3.play(); break;
                }
            }

            function fail() {
                state = GS_Failed;
                bfail.play();
                lastHitStartAngle = 0;
            }

            function performShuffle() {
                // prep array
                var newPos = [];
                var possiblePos = [0, 1, 2, 3];                
                for (var i = 0; i < shuffleQty; ++i) newPos.push(possiblePos.splice(RNG_ColorShuffle.nextInt(possiblePos.length), 1)); 
                //console.log(newPos);

                // variable length swap
                var b = shuffle[newPos[0]];
                for (var i = 0; i < shuffleQty - 1; ++i) shuffle[newPos[i]] = shuffle[newPos[i+1]];
                shuffle[newPos[shuffleQty - 1]] = b;
            }


            function performSoundShuffle() {
                // prep array
                var newPos = [];
                var possiblePos = [0, 1, 2, 3];                
                for (var i = 0; i < shuffleQty; ++i) newPos.push(possiblePos.splice(RNG_ColorShuffle.nextInt(possiblePos.length), 1)); 
                //console.log(newPos);

                // variable length swap
                var b = soundShuffle[newPos[0]];
                for (var i = 0; i < shuffleQty - 1; ++i) soundShuffle[newPos[i]] = soundShuffle[newPos[i+1]];
                soundShuffle[newPos[shuffleQty - 1]] = b;
            }




            // Scene
            function updateScene() {            
                // stats and shit
                strList.set("state", GS_Strings[state]);
                //strList.set("s", "[" + shuffle[0] + "," + shuffle[1] + "," + shuffle[2] + "," + shuffle[3] + "]");
                strList.set("shuffle", "\n" + CSM_Strings[colorShuffleMode]);
                strList.set("shuffle n", shuffleQty);
                strList.set("sound", "\n" + SSM_Strings[soundSuffleMode]);
                strList.set("level", currentLevel + 1);
                strList.set("step", currentStep);
                //strList.set("stepDelay", teachDelayBase - (teachDelayDecrements * currentLevel));


                // inputs
                if ((newUserInput > 0) && (newUserInput < 5)) {
                    playColor(newUserInput);
                    lastHitStartAngle += (360 * timeSinceLastHit / maxTimeBetweenHit);
                    if (lastHitStartAngle > 360) lastHitStartAngle -= 360;
                    timeSinceLastHit = 0;
                    //console.log("input: " + newUserInput);
                    userInput = newUserInput;
                    userInputDelay = flashDelay;
                }



                // Game Logic 
                if (state == GS_Recall) {
                    if (timeSinceLastHit > maxTimeBetweenHit) {
                        fail();
                    } else if ((newUserInput > 0) && (newUserInput < 5)) {
                        //console.log("recalled: " + newUserInput);
                        if (newUserInput == seq[currentStep]) {
                            currentStep++;
                            if (currentStep > currentLevel) {
                                state = GS_Success;
                                stepDelayRemaining = successDelay;
                            }
                            if (colorShuffleMode == CSM_AfterEachRecalls) performShuffle();
                            if (colorShuffleMode == CSM_BeforeEachRecalls) performShuffle();
                        } else fail();
                    }
 
                }
                if ((state == GS_Idle) || (state == GS_Failed)) {
                    if (newUserInput == 5) {
                        seq = [];
                        seq.push(RNG_Sequence.nextInt(4) + 1);
                        if (colorShuffleMode == CSM_BeforeTeach) performShuffle();
                        state =  GS_Teach;
                        currentLevel = 0;
                        currentStep = 0;
                        stepDelayRemaining = teachDelayBase;
                    } 
                }
                if (state == GS_Teach) {
                    stepDelayRemaining -= timeDelta;
                    if (stepDelayRemaining <= 0) {

                        if (currentStep > currentLevel) {
                            if (colorShuffleMode == CSM_AfterTeach) performShuffle();
                            if (colorShuffleMode == CSM_BeforeEachRecalls) performShuffle();
                            if (soundSuffleMode == SSM_AfterTeach) performSoundShuffle();
                            state = GS_Recall;
                            timeSinceLastHit = 0;
                            currentStep = 0;
                        } else {
                            userInput = seq[currentStep];
                            userInputDelay = flashDelay;
                            //console.log("teach: " + newUserInput);
                            playColor(userInput);
                            currentStep++;
                        } 

                        //reset delay
                        stepDelayRemaining = teachDelayBase - (teachDelayDecrements * currentLevel);
                        if (stepDelayRemaining < teachDelayMin) stepDelayRemaining = teachDelayMin;

                    } // delay reached
                }// state teach

                if (state == GS_Success) {
                    stepDelayRemaining -= timeDelta;
                    if (stepDelayRemaining <= 0) {
                        currentStep = 0;
                        seq.push(RNG_Sequence.nextInt(4) + 1);
                        currentLevel++;
                        if (colorShuffleMode == CSM_BeforeTeach) performShuffle();
                        if (soundSuffleMode == SSM_EachLevel) performSoundShuffle();
                        state = GS_Teach;
                        stepDelayRemaining = teachDelayBase;
                    }
                }

            }

            function drawScene(){                
                // clear
                ctx.clearRect(-1, -1, 2, 2);
                clear = false;

                // text
                log.innerText = "";
                strList.forEach((a, b) => { log.innerText += (b + ": " + a) + "\n"; } );
                
                // grid
                ctx.setLineDash([]);
                ctx.strokeStyle = "#888";
                ctx.beginPath();
                for (var i = -10; i <= 10; ++i) {
                    line((i/10), -1.0, (i/10), 1.0);
                    line(-1.0, (i/10), 1.0, (i/10));
                }
                ctx.stroke();

                // origin
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 3.0 / viewportScale;
                ctx.setLineDash([20 / viewportScale, 3 / viewportScale, 3 / viewportScale, 3 / viewportScale]);
                ctx.beginPath();
                line( 0.0, -1.0, 0.0, 1.0);
                line(-1.0,  0.0, 1.0, 0.0);
                ctx.stroke();

                // draw objects
                ctx.setLineDash([]);
                ctx.lineWidth = 2.0 / viewportScale;

                // frame
                ctx.fillStyle = "black";
                arcFill(0, 0, 0.45, 0, 360);

                // buttons
                var flashIndex = (userInputDelay > 0) ? userInput : -1;
                ctx.fillStyle = fillStyles[flashIndex - 1 == shuffle[0] ? 1 : 0][shuffle[0]];
                arcFill(0.0, 0.0, 0.4, 0, 90);
                ctx.fillStyle = fillStyles[flashIndex - 1 == shuffle[1] ? 1 : 0][shuffle[1]];
                arcFill(0.0, 0.0, 0.4, 90, 180);
                ctx.fillStyle = fillStyles[flashIndex - 1 == shuffle[2] ? 1 : 0][shuffle[2]];
                arcFill(0.0, 0.0, 0.4, 180, 270);
                ctx.fillStyle = fillStyles[flashIndex - 1 == shuffle[3] ? 1 : 0][shuffle[3]];
                arcFill(0.0, 0.0, 0.4, 270, 0);

                ctx.fillStyle = "black";
                ctx.fillRect(-0.42, -0.05, 0.84, 0.1);
                ctx.fillRect(-0.05, -0.42, 0.1, 0.84);

                ctx.lineWidth = 1.0 / viewportScale;
                ctx.fillStyle = "white";

                if (state == GS_Idle) {
                    ctx.strokeStyle = "white";
                    ctx.strokeRect(-0.3, -0.04, 0.6, 0.08);
                    drawImageScaledCentered(startImage, 0.0, 0.0, 2.0);
                
                } else if (state == GS_Teach) {
                    drawImageScaledCentered(eyeImage, 0.0, 0.0, 0.6);
                    
                } else if (state == GS_Recall) {
                    var t = (maxTimeBetweenHit - timeSinceLastHit) / maxTimeBetweenHit;
                    var baseColor = 255 - (255 * t * t);
                    baseColor = Math.round(baseColor).toString(16).padStart(2, "0");
                    ctx.strokeStyle = "#" + baseColor + "" + baseColor + "" + baseColor;
                    ctx.lineWidth = 5.0 / viewportScale;
                    arcStroke(0, 0, 0.425, (360 * timeSinceLastHit / maxTimeBetweenHit) - 90 + lastHitStartAngle, 270 + lastHitStartAngle);
                    ctx.lineWidth = 1.0 / viewportScale;

                } else if (state == GS_Failed) {
                    drawImageScaledCentered(crossImage, 0.0, 0.0, 0.4);
                    ctx.strokeStyle = "white";
                    ctx.strokeRect(0.06, -0.04, 0.34, 0.08);
                    drawImageScaledCentered(newImage, 0.23, 0.0, 1.4);
                } else if (state == GS_Success) {
                    drawImageScaledCentered(checkImage, 0.0, 0.0, 0.4);
                }

                var w = c.offsetWidth;
                var h = c.offsetHeight;
                ctx.strokeStyle = "#F00";
                ctx.lineWidth = 1.0;
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(w, h);
                ctx.moveTo(0, h);
                ctx.lineTo(w, 0);
                ctx.stroke();
                ctx.restore();
                ctx.lineWidth = 1.0 / viewportScale;

            }

            function cleanupScene(){
                lastX = currentX;
                lastY = currentY;
                lastT = time;
                newUserInput = 0;
                timeSinceLastHit += timeDelta;
                userInputDelay -= timeDelta;
            }









            // Context drawing methods

            function line(x1, y1, x2, y2) {
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
            }
            function circleFill(x, y, r) {
                ctx.beginPath();
                ctx.arc(x,
                        y,
                        r,
                        0,
                        Math.PI * 2.0);
                ctx.fill();
            }
            function circleStroke(x, y, r) {
                ctx.beginPath();
                ctx.arc(x,
                        y,
                        r,
                        0,
                        Math.PI * 2.0);
                ctx.stroke();
            }
            function arcFill(x, y, r, startAngle, endAngle) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.arc(x,
                        y,
                        r, 
                        startAngle * DegToRad, 
                        endAngle * DegToRad);
                ctx.lineTo(x, y);
                ctx.fill();
            }

            function arcStroke(x, y, r, startAngle, endAngle) {
                ctx.moveTo(x, y);
                ctx.beginPath();
                ctx.arc(x,
                        y,
                        r,
                        startAngle * DegToRad,
                        endAngle * DegToRad);
                ctx.stroke();
            }
            function drawImageScaledCentered(img, x, y, scale = 1.0) {
                var w = img.width * scale;
                var h = img.height * scale;
                w = w / viewportScale * globalViewScale;
                h = h / viewportScale * globalViewScale;
                ctx.drawImage(img, x - (w / 2), y - (h / 2), w, h);
            }

        } );
        // TODO local scoreboard
        // TODO global leaderboard - tab for total, tabs for each mode 
        // TODO header bar with level/step/status/csm/ssm
    </script>
</head>

<body>
    <div class="E3D_fullscreenContainer E3D_flexVertical">

        <div id="statusDiv" class="E3D_flexVerticalContentFit" style="background-color: yellowgreen;">
            <span id="statusSpan" class="E3D_monospaceText">Color Shuffle:$mode, Sound Suflle:$sound, Stage:$state, Level:$level, Step: $step</span>
        </div>     

        <div class="E3D_flexContent">
            <div id="log"></div>

            <canvas id="canvas" width="192" height="108">Canvas</canvas>

            <div id="volDiv">
                <span id="volSpan">Volume:</span>
                <input id="vol" type="range" min="0" max="2" value="1" step="0.1" />
                <div id="shuffleModeButton" class="E3D_fakeButton">Shuffle Mode</div>
                <div id="shuffleQtyButton" class="E3D_fakeButton">Shuffle Qty.</div>
                <div id="shuffleSoundButton" class="E3D_fakeButton">Sound Shuffle</div>
            </div>
        </div>

        <div id="helpDiv" class="hoverSize">
            <img id="help" src="media/Help.svg" width="50" height="50" /></img><br />
            EN: <br />
            Learn the color pattern and repeat to advance to the next level <hr />
            Shuffle Modes: <br />
            N: Colors stay at the same place <br />
            L: Colors shuffle at the begining of the level <br />
            M: Colors shuffle after the memorization stage <br />
            P: Colors shuffle after each player input in the recall stage <br />
            R: Colors shuffle after each color ligts up in the memorization stage <br />
            E: Colors shuffle everytime before they light up. <hr />
            Shuffle QTY:<br />
            Number of colors that get shuffled.<hr />
            Sound Suffle:<br />
            Association of sounds and colors also get shuffled.<br />            
        </div>

    </div>

    <div id="hiddenMedia">
        <audio id="b0" src="media/Beep0.wav"></audio>
        <audio id="b1" src="media/Beep1.wav"></audio>
        <audio id="b2" src="media/Beep2.wav"></audio>
        <audio id="b3" src="media/Beep3.wav"></audio>
        <audio id="fail" src="media/Fail.wav"></audio>
        <img id="check" src="media/Check.svg"></img>
        <img id="cross" src="media/Cross.svg"></img>
        <img id="eye" src="media/Eye.svg"></img>
    </div>
    
</body>

</html>
