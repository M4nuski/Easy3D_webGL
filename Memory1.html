<!DOCTYPE html>
<html>
<head>
    <title>Memory Game 1</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        body {
            margin: 0px;
            font-size: 24px;
            font-family: Arial, Helvetica, sans-serif;
        }
        canvas {
            width: 100%;
            height: 100%;
            z-index: 0;
            position: absolute;
            top: 0px;
            left: 0px;
        }
        .E3D_fullscreenContainer {
            position:fixed;
            top:0px;
            bottom:0px;
            right:0px;
            left:0px;
        }
        #log {
            background-color: transparent;
            z-index: 10;
            position: absolute;
            top: 0px;
            left: 0px;
            padding: 5px;
            border-radius: 5px;
            border: 2px solid black;
        }
        #volDiv {
            position: absolute;
            top: 0px;
            right: 0px;
            z-index: 10;
            text-align: center;
            border-radius: 5px;
            border: 2px solid black;
        }
        #volSpan {
            display: block; 
            background-color: white;
        }
    </style>

    <script type="text/javascript">
        document.addEventListener("DOMContentLoaded", function() { 

            var c = document.getElementById("canvas");
            var ctx = c.getContext("2d");
            var width = 1920;
            var height = 1080;

            const DegToRad = (Math.PI / 180.0);

            var viewportScale = 1.0;
            var viewportOffsetX = 0;
            var viewportOffsetY = 0;

            var canvasZoom = 1.0;
            var canvasOffsetX = 0;
            var canvasOffsetY = 0;

            window.addEventListener("resize", resizeViewport);
            c.addEventListener("mousedown", canvasMouseDown);
           // c.addEventListener("touchstart", canvasTouchStart);
            c.addEventListener("mousemove", canvasMouseMove);
            c.addEventListener("mouseup", canvasMouseUp);
            c.addEventListener("wheel", canvasMouseWheel);
            c.addEventListener("mouseleave", canvasMouseLeave);
            document.addEventListener("keydown", canvasKeyDown);
            
            var currentX = 0;
            var currentY = 0;

            var lastX = 0;
            var lastY = 0;
          
            var cX = 0;
            var cY = 0;
            var lX = 0;
            var lY = 0;
            mouseDn0 = false;
            mouseDn1 = false;
            mouseDn2 = false;
            mouseDg0 = false;
            mouseDg1 = false;
            mouseDg2 = false;
            mouseUp0 = false;
            mouseUp1 = false;
            mouseUp2 = false;
            mouseW = 0;

            function setAudio() {
                audioContext = new window.AudioContext();
                gainNode = audioContext.createGain();

                b0 = getElem("b0");
                var t0 = audioContext.createMediaElementSource(b0);
                t0.connect(gainNode).connect(audioContext.destination);

                b1 = getElem("b1");
                var t1 = audioContext.createMediaElementSource(b1);
                t1.connect(gainNode).connect(audioContext.destination);

                b2 = getElem("b2");
                var t2 = audioContext.createMediaElementSource(b2);
                t2.connect(gainNode).connect(audioContext.destination);

                b3 = getElem("b3");
                var t3 = audioContext.createMediaElementSource(b3);
                t3.connect(gainNode).connect(audioContext.destination);

                bfail = getElem("fail");
                var tfail = audioContext.createMediaElementSource(bfail);
                tfail.connect(gainNode).connect(audioContext.destination);
            }

            function canvasMouseDown(event) {
                if (event.button == 0) mouseDn0 = true;
                if (event.button == 1) mouseDn1 = true;
                if (event.button == 2) mouseDn2 = true;

                if (!audioContext) setAudio();
                if (event.preventDefault) { event.preventDefault(); };
                return false;
            }

     /*       function canvasTouchStart(event) {
                if (!audioContext) setAudio();
                var touch = event.changedTouches[0];
                currentX = (((touch.pageX - c.offsetLeft) / canvasZoom) - viewportOffsetX) / viewportScale;
                currentY = (((touch.pageY - c.offsetTop) / canvasZoom) - viewportOffsetY) / viewportScale;  
                cX = touch.pageX;
                cY = touch.pageY;
                canvasMouseDown({button: 0});
            }*/

            function canvasMouseMove(event) {
                currentX = (((event.pageX - c.offsetLeft) / canvasZoom) - viewportOffsetX) / viewportScale;
                currentY = (((event.pageY - c.offsetTop) / canvasZoom) - viewportOffsetY) / viewportScale;  
                cX = event.pageX;
                cY = event.pageY;
            }

            function canvasMouseUp(event) {
                if (event.button == 0) mouseUp0 = true;
                if (event.button == 1) mouseUp1 = true;
                if (event.button == 2) mouseUp2 = true;

                if (event.preventDefault) { event.preventDefault(); };
                return false;
            }
            function canvasMouseWheel(event) {   
                mouseW = (event.deltaY > 0) ? 1 : -1;
            }
            function canvasMouseLeave() {
                var lX = 0;
                var lY = 0;
                mouseDn0 = false;
                mouseDn1 = false;
                mouseDn2 = false;
                mouseDg0 = false;
                mouseDg1 = false;
                mouseDg2 = false;
                mouseUp0 = false;
                mouseUp1 = false;
                mouseUp2 = false;
                mouseW = 0;
            }

            function canvasKeyDown(event) {
                if (event.key == "i") strList.set("state", "Idle");
                if (event.key == "f") strList.set("state", "Failed");
                if (event.key == "t") strList.set("state", "Teach");
                if (event.key == "r") strList.set("state", "Recall");
                timeSinceLastHit = 0;
            }

            function resizeViewport() {
                width = c.offsetWidth;
                height = c.offsetHeight;

                c.width = width;
                c.height = height;

                // "view matrix"
                // largest size is +/- 1.0
                // other is AR proportionnal
                var ar = width / height;

                if (ar > 1.0) {
                    var s = width / 2.0;
                    viewportScale = width / 2.0;
                    viewportOffsetX = viewportScale;
                    viewportOffsetY = viewportScale / ar;
                } else {
                    viewportScale = height / 2.0;
                    viewportOffsetX = viewportScale * ar;
                    viewportOffsetY = viewportScale;
                }
                globalViewScale = viewportScale / 1080;

                resizeCanvas();
            }

            function resizeCanvas(f) {
                c.style.width =  (canvasZoom * 100) + "%";
                c.style.height = (canvasZoom * 100) + "%";

                c.style.top =  (canvasOffsetY - (c.offsetHeight - c.height) / 2 ) + "px"; 
                c.style.left = (canvasOffsetX - (c.offsetWidth  - c.width)  / 2 ) + "px";
            }

            // Seeded RNG based on https://gist.github.com/blixt/f17b47c62508be59987b
            class Random {
                constructor(seed) {
                    this._seed = seed % 2147483647;
                    if (this._seed <= 0) this._seed += 2147483646;
                }
                // Returns a pseudo-random value between 1 and 2^32 - 2.
                next() {
                    return this._seed = this._seed * 16807 % 2147483647;
                }
                // Returns a pseudo-random floating point number in range [0.0, 1.0-epsilon].
                nextFloat() {        
                    return (this.next() - 1) / 2147483646; // We know that result of next() will be 1 to 2147483646 (inclusive).
                }
                // Returns a pseudo-random integer in range [0, maxInt-1].
                nextInt(maxInt) {
                    return Math.floor(maxInt * (this.next() - 1) / 2147483646);
                }
            }
            function getElem(id) {
                var elem = document.getElementById(id);
                if (elem) return elem;
                return false;
            }

            var newUserInput = 0;
            var strList = new Map();
            strList.set("state", "Idle");

            // Idle
            // Teach show sequence
            // Recall wait for user sequence
            // Failed
            // Success

            var time = 0;
            var timeLast = 0;
            var timeDelta = 0;
            var timeScale = 1.0;
            var frame = 0;
            var frameInterval = 5; // update scene every "frameInterval" frames
            var run = true;

            // Audio Stuff
            var audioContext, gainNode;
            var b0, b1, b2, b3, bfail;
            var t0, t1, t2, t3, tfail;

            var fillStyles = [
                ["red", "green", "blue", "yellow"],
                ["#FF8080", "#80FF80", "#8080FF", "#FFFFA0"]
            ];

            var timeSinceLastHit = 0.0;
            const maxTimeBetweenHit = 1.5;
            var lastHitStartAngle = 0;

            const teachDelayBase = 0.5;
            const teachDelayMin = 0.15;
            const teachDelayDecrements = 0.02;

            var currentLevel = 0;
            var currentStep = 0;
            var seq = [];
            var rng = new Random(666);

            // volume slider
            var volSlider = getElem("vol");
            if (window.localStorage) {
                var v = window.localStorage.getItem("m1.vol");
                if (v != undefined) {
                    volSlider.value = v;
                }
            }
            volSlider.addEventListener("input", function (event) { 
                if (gainNode) gainNode.gain.value = this.value; 
                if (window.localStorage) window.localStorage.setItem("m1.vol", this.value);
            });



            resizeViewport();
            startLoop();

            function startLoop() {
                window.requestAnimationFrame((startTime) => { 
                    timeLast = startTime; 
                    window.requestAnimationFrame(gameLoop); 
                } );
            }

            function gameLoop(t) {
                frame++;
                if ((frame % frameInterval) == 0) {
                    timeKeeping(t);
                    updateInputs();
                    if (run) {
                        updateScene();
                        drawScene();
                        cleanupScene();
                    }
                }
                window.requestAnimationFrame(gameLoop);
            }

            function timeKeeping(newTime) {
                timeDelta = ((newTime - timeLast) * timeScale) / 1000.0;
                if (run) time += timeDelta;
                timeLast = newTime;
            }

            function updateInputs() {
                // handle mouse down
                if (mouseDn0) {
                    mouseDn0 = false;
                    mouseDg0 = true;

                    checkHitRegion(currentX, currentY);
                }
                if (mouseDn1) {
                    mouseDn1 = false;
                    mouseDg1 = true;
                    lX = cX;
                    lY = cY;
                }
                if (mouseDn2) {
                    mouseDn2 = false;
                    mouseDg2 = true;
                }

                // handle mouse up
                if (mouseUp0) {
                    mouseUp0 = false;
                    mouseDg0 = false;
                }                
                if (mouseUp1) {
                    mouseUp1 = false;
                    mouseDg1 = false;
                }                
                if (mouseUp2) {
                    mouseUp2 = false;
                    mouseDg2 = false;
                }

                // handle mouse drag
                if (mouseDg0) {
                    //
                }                
                if (mouseDg1) {
                    canvasOffsetX += cX - lX;
                    canvasOffsetY += cY - lY;
                    lX = cX;
                    lY = cY;
                    resizeCanvas();
                }                
                if (mouseDg2) {
                    //
                }

                if (mouseW < 0) {
                //    canvasZoom = canvasZoom * 1.25;
                    mouseW = 0;
                    resizeCanvas();
                }
                if (mouseW > 0) {
                 //   canvasZoom = canvasZoom / 1.25;
                    mouseW = 0;
                    resizeCanvas();
                }
            }

            function checkHitRegion(x, y) {
                //strList.set("X", x.toFixed(3));
                //strList.set("Y", y.toFixed(3));
                //strList.set("region", "out");
                if (strList.get("state") != "Teach") {
                    var d = Math.sqrt((x * x) + (y * y));
                    if ((d > 0.05) && (d < 0.40)) {
                        if ((x > 0.05) && (y > 0.05)) {
                            //strList.set("region", "red");
                            newUserInput = 1;
                        }
                        if ((x < -0.05) && (y > 0.05)) {
                            //strList.set("region", "green");
                            newUserInput = 2;
                        }
                        if ((x < -0.05) && (y < -0.05)) {
                            //strList.set("region", "blue");
                            newUserInput = 3;
                        }
                        if ((x > 0.05) && (y < -0.05)) {
                            //strList.set("region", "yellow");
                            newUserInput = 4;
                        }
                    }
                    if ((x > -0.40) && (x < 0.40) && (y > -0.05) && (y < 0.05)) {
                        //strList.set("region", "new");
                        newUserInput = 5;
                    }
                }
            }

            function playColor(index) {
                if (audioContext) switch (index) {
                    case 1: b0.play(); break;
                    case 2: b1.play(); break;
                    case 3: b2.play(); break;
                    case 4: b3.play(); break;
                }
            }

            function fail() {
                strList.set("state", "Failed");
                //strList.set("region", "out");
                bfail.play();
                lastHitStartAngle = 0;
            }

            function updateScene() {            
                // stats and shit
                //strList.set("time", time.toFixed(2));   
                strList.set("level", currentLevel);
                strList.set("step", currentStep);             

                // inputs
                if (newUserInput > 0 && (newUserInput < 5)) {
                    playColor(newUserInput);
                    lastHitStartAngle += (360 * timeSinceLastHit / maxTimeBetweenHit);
                    if (lastHitStartAngle > 360) lastHitStartAngle -= 360;
                    timeSinceLastHit = 0;
                }
                    
                // state 
                if (strList.get("state") == "Recall") {
                    if (timeSinceLastHit > maxTimeBetweenHit) {
                        fail();
                    } else if ((newUserInput > 0) && (newUserInput < 5)) {
                        if (newUserInput == seq[currentStep] + 1) {
                            currentStep++;
                            if (currentStep > currentLevel) strList.set("state", "Success");
                        } else fail();
                    }
 
                }
                if ((strList.get("state") == "Idle") || (strList.get("state") == "Failed")) {
                    if (newUserInput == 5) {
                        seq = [];
                        seq.push(rng.nextInt(4));
                        strList.set("state", "Teach");
                        currentLevel = 0;
                        currentStep = 0;
                        stepDelayRemaining = teachDelayBase;
                    } 
                }
                if (strList.get("state") == "Teach") {
                    stepDelayRemaining -= timeDelta;
                    if (stepDelayRemaining <= 0) {

                        if (currentStep > (currentLevel + 1)) {
                            strList.set("state", "Recall");
                            timeSinceLastHit = 0;
                            currentStep = 0;
                        } else {
                            newUserInput = seq[currentStep - 1] + 1;
                            playColor(newUserInput);
                            currentStep++;
                        } 

                        //reset delay
                        stepDelayRemaining = teachDelayBase - teachDelayDecrements * currentLevel;
                        if (stepDelayRemaining < teachDelayMin) stepDelayRemaining = teachDelayMin;

                    } // delay reached
                }// state teach

                if (strList.get("state") == "Success") {
                    currentStep = 0;
                    seq.push(rng.nextInt(4));
                    currentLevel++;
                    strList.set("state", "Teach");
                    stepDelayRemaining = teachDelayBase;
                }

            }

            function drawScene(){                
                // clear
                ctx.clearRect(0, 0, width, height);
                clear = false;

                // text
                log.innerText = "";
                strList.forEach((a, b) => { log.innerText += (b + ": " + a) + "\n"; } );
                
                // grid
                ctx.setLineDash([]);
                ctx.strokeStyle = "#888";
                ctx.beginPath();
                for (var i = -10; i <= 10; ++i) {
                    line((i/10), -1.0, (i/10), 1.0);
                    line(-1.0, (i/10), 1.0, (i/10));
                }
                ctx.stroke();

                // origin
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 3.0;
                ctx.setLineDash([20, 3, 3, 3]);
                ctx.beginPath();
                line( 0.0, -1.0, 0.0, 1.0);
                line(-1.0,  0.0, 1.0, 0.0);
                ctx.stroke();

                // draw objects
                ctx.setLineDash([]);
                ctx.lineWidth = 2.0;

                // frame
                ctx.fillStyle = "black";
                arc(0, 0, 0.45, 0, 360);

                // buttons
                ctx.fillStyle = fillStyles[newUserInput == 1 ? 1 : 0][0];
                arc(0.0, 0.0, 0.4, 0, 90);
                ctx.fillStyle = fillStyles[newUserInput == 2 ? 1 : 0][1];
                arc(0.0, 0.0, 0.4, 90, 180);
                ctx.fillStyle = fillStyles[newUserInput == 3 ? 1 : 0][2];
                arc(0.0, 0.0, 0.4, 180, 270);
                ctx.fillStyle = fillStyles[newUserInput == 4 ? 1 : 0][3];
                arc(0.0, 0.0, 0.4, 270, 0);

                ctx.fillStyle = "black";
                rect(-0.42, -0.05, 0.84, 0.1);
                rect(-0.05, -0.42, 0.1, 0.84);

                ctx.lineWidth = 1.0;
                ctx.fillStyle = "white";

                if (strList.get("state") == "Idle") {
                    var fs = 80 * globalViewScale;
                    ctx.font = fs + "px Lucida Console";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText('Start Game', viewportOffsetX, viewportOffsetY);
                    ctx.strokeStyle = "white";
                    ctx.strokeRect(-0.3 * viewportScale + viewportOffsetX, -0.04 * viewportScale + viewportOffsetY, 0.6 * viewportScale, 0.08 * viewportScale);
                
                } else if (strList.get("state") == "Teach") {
                    ctx.fillStyle = "yellow";
                    ctx.beginPath();
                    circle(0, 0, 0.05);
                    ctx.fill();
                    
                } else if (strList.get("state") == "Recall") {
                    var baseColor = 255 - (240 * (maxTimeBetweenHit - timeSinceLastHit) / maxTimeBetweenHit);
                    baseColor = Math.round(baseColor).toString(16).padStart(2, "0");
                    ctx.strokeStyle = "#" + baseColor + "" + baseColor + "" + baseColor;
                    ctx.lineWidth = 15.0 * globalViewScale;
                    arcStroke(0, 0, 0.425, (360 * timeSinceLastHit / maxTimeBetweenHit) - 90 + lastHitStartAngle, 270 + lastHitStartAngle);
                    ctx.lineWidth = 1.0;

                } else if (strList.get("state") == "Failed") {
                    ctx.fillStyle = "red";
                    ctx.beginPath();
                    circle(0, 0, 0.05);
                    ctx.fill();
                    ctx.fillStyle = "white";
                    var fs = 80 * globalViewScale;
                    ctx.font = fs + "px Lucida Console";
                    ctx.textAlign = "start";
                    ctx.textBaseline = "middle";
                    ctx.fillText('Restart', 0.06 * viewportScale + viewportOffsetX, viewportOffsetY);
                    ctx.strokeStyle = "white";
                    ctx.strokeRect(0.06 * viewportScale + viewportOffsetX, -0.04 * viewportScale + viewportOffsetY, 0.32 * viewportScale, 0.08 * viewportScale);
                }

            }

            function cleanupScene(){
                lastX = currentX;
                lastY = currentY;
                lastT = time;
                newUserInput = 0;
                timeSinceLastHit += timeDelta;
            }









            // Context drawing methods
            function moveTo(x, y) {
                ctx.moveTo(x * viewportScale + viewportOffsetX, y * viewportScale + viewportOffsetY);
            }
            function lineTo(x, y) {
                ctx.lineTo(x * viewportScale + viewportOffsetX, y * viewportScale + viewportOffsetY);
            }
            function line(x1, y1, x2, y2) {
                ctx.moveTo(x1 * viewportScale + viewportOffsetX, y1 * viewportScale + viewportOffsetY);
                ctx.lineTo(x2 * viewportScale + viewportOffsetX, y2 * viewportScale + viewportOffsetY);
            }
            function circle(x, y, r) {
                ctx.arc(x * viewportScale + viewportOffsetX,
                        y * viewportScale + viewportOffsetY,
                        r * viewportScale, 0, Math.PI * 2.0);
            }
            function arc(x, y, r, startAngle, endAngle) {
                ctx.beginPath();
                ctx.moveTo(x * viewportScale + viewportOffsetX, y * viewportScale + viewportOffsetY);
                ctx.arc(x * viewportScale + viewportOffsetX,
                        y * viewportScale + viewportOffsetY,
                        r * viewportScale, startAngle * DegToRad, endAngle * DegToRad);
                ctx.lineTo(x * viewportScale + viewportOffsetX, y * viewportScale + viewportOffsetY);   

                ctx.fill();
            }
            function rect(x, y, w, h) {
                ctx.fillRect(x * viewportScale + viewportOffsetX,
                             y * viewportScale + viewportOffsetY,
                             w * viewportScale,
                             h * viewportScale)
            }
            function arcStroke(x, y, r, startAngle, endAngle) {
                ctx.moveTo(x * viewportScale + viewportOffsetX, y * viewportScale + viewportOffsetY);
                ctx.beginPath();
                ctx.arc(x * viewportScale + viewportOffsetX,
                        y * viewportScale + viewportOffsetY,
                        r * viewportScale, startAngle * DegToRad, endAngle * DegToRad);
                ctx.stroke();
            }

        } );
    </script>
</head>

<body>
    <div class="E3D_fullscreenContainer">
        <canvas id="canvas" width="1920" height="1080">Canvas</canvas>
        <div id="log"></div>
        <div id="volDiv">
            <span id="volSpan">Volume:</span>
            <input id="vol" type="range" min="0" max="2" value="1" step="0.1" />
        </div>
    </div>
    <audio id="b0" src="media/Beep0.wav"></audio>
    <audio id="b1" src="media/Beep1.wav"></audio>
    <audio id="b2" src="media/Beep2.wav"></audio>
    <audio id="b3" src="media/Beep3.wav"></audio>
    <audio id="fail" src="media/Fail.wav"></audio>
</body>

</html>
